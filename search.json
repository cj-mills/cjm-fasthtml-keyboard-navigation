[
  {
    "objectID": "js/utils.html",
    "href": "js/utils.html",
    "title": "JavaScript Utilities",
    "section": "",
    "text": "source\n\n\n\ndef js_config_from_dict(\n    config:dict[str, Any], # Python dict to convert\n    var_name:str='cfg', # JavaScript variable name\n)-&gt;str: # JavaScript const declaration\n\nGenerate JavaScript const declaration from Python dict.\n\n# Test config generation\nresult = js_config_from_dict({\"key\": \"value\", \"num\": 42})\nassert \"const cfg\" in result\nassert '\"key\"' in result\nassert '\"value\"' in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#configuration-injection",
    "href": "js/utils.html#configuration-injection",
    "title": "JavaScript Utilities",
    "section": "",
    "text": "source\n\n\n\ndef js_config_from_dict(\n    config:dict[str, Any], # Python dict to convert\n    var_name:str='cfg', # JavaScript variable name\n)-&gt;str: # JavaScript const declaration\n\nGenerate JavaScript const declaration from Python dict.\n\n# Test config generation\nresult = js_config_from_dict({\"key\": \"value\", \"num\": 42})\nassert \"const cfg\" in result\nassert '\"key\"' in result\nassert '\"value\"' in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#input-detection",
    "href": "js/utils.html#input-detection",
    "title": "JavaScript Utilities",
    "section": "Input Detection",
    "text": "Input Detection\n\nsource\n\njs_input_detection\n\ndef js_input_detection(\n    selector:str=\"input, textarea, select, [contenteditable='true']\", # CSS selector for input elements\n)-&gt;str: # JavaScript function definition\n\nGenerate JavaScript function to detect if input element is focused.\n\n# Test input detection\nresult = js_input_detection()\nassert \"function isInputFocused\" in result\nassert \"target.matches\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#focus-ring-helpers",
    "href": "js/utils.html#focus-ring-helpers",
    "title": "JavaScript Utilities",
    "section": "Focus Ring Helpers",
    "text": "Focus Ring Helpers\n\nsource\n\njs_focus_ring_helpers\n\ndef js_focus_ring_helpers(\n    default_classes:tuple[str, ...]=('ring-2', 'ring-primary'), # default focus ring CSS classes\n)-&gt;str: # JavaScript function definitions\n\nGenerate JavaScript functions for adding/removing focus ring classes.\n\n# Test focus ring helpers\nresult = js_focus_ring_helpers()\nassert \"function addFocusRing\" in result\nassert \"function removeFocusRing\" in result\nassert str(ring(2)) in result\nassert str(ring_dui.primary) in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#scroll-into-view",
    "href": "js/utils.html#scroll-into-view",
    "title": "JavaScript Utilities",
    "section": "Scroll Into View",
    "text": "Scroll Into View\n\nsource\n\njs_scroll_into_view\n\ndef js_scroll_into_view(\n    behavior:str='smooth', # \"smooth\" or \"auto\"\n    block:str='nearest', # \"start\", \"center\", \"end\", \"nearest\"\n)-&gt;str: # JavaScript function definition\n\nGenerate JavaScript function to scroll element into view.\n\n# Test scroll helper\nresult = js_scroll_into_view()\nassert \"function scrollToElement\" in result\nassert \"scrollIntoView\" in result\nassert \"smooth\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#hidden-input-update",
    "href": "js/utils.html#hidden-input-update",
    "title": "JavaScript Utilities",
    "section": "Hidden Input Update",
    "text": "Hidden Input Update\n\nsource\n\njs_hidden_input_update\n\ndef js_hidden_input_update(\n    \n)-&gt;str: # JavaScript function definition\n\nGenerate JavaScript function to update hidden input values.\n\n# Test hidden input update\nresult = js_hidden_input_update()\nassert \"function updateHiddenInput\" in result\nassert \"function updateHiddenInputs\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#button-click-trigger",
    "href": "js/utils.html#button-click-trigger",
    "title": "JavaScript Utilities",
    "section": "Button Click Trigger",
    "text": "Button Click Trigger\n\nsource\n\njs_trigger_click\n\ndef js_trigger_click(\n    \n)-&gt;str: # JavaScript function definition\n\nGenerate JavaScript function to programmatically click a button.\n\n# Test trigger click\nresult = js_trigger_click()\nassert \"function triggerClick\" in result\nassert \"button.click()\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#data-attribute-extraction",
    "href": "js/utils.html#data-attribute-extraction",
    "title": "JavaScript Utilities",
    "section": "Data Attribute Extraction",
    "text": "Data Attribute Extraction\n\nsource\n\njs_get_data_attributes\n\ndef js_get_data_attributes(\n    \n)-&gt;str: # JavaScript function definition\n\nGenerate JavaScript function to extract data attributes from element.\n\n# Test data attribute extraction\nresult = js_get_data_attributes()\nassert \"function getDataAttributes\" in result\nassert \"getAttribute\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#modifier-key-detection",
    "href": "js/utils.html#modifier-key-detection",
    "title": "JavaScript Utilities",
    "section": "Modifier Key Detection",
    "text": "Modifier Key Detection\n\nsource\n\njs_get_modifiers\n\ndef js_get_modifiers(\n    \n)-&gt;str: # JavaScript function definition\n\nGenerate JavaScript function to extract modifier keys from event.\n\n# Test modifier detection\nresult = js_get_modifiers()\nassert \"function getModifiers\" in result\nassert \"function modifiersMatch\" in result\nassert \"shiftKey\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "js/utils.html#combined-utilities",
    "href": "js/utils.html#combined-utilities",
    "title": "JavaScript Utilities",
    "section": "Combined Utilities",
    "text": "Combined Utilities\nFunction to generate all utility functions at once.\n\nsource\n\njs_all_utils\n\ndef js_all_utils(\n    input_selector:str=\"input, textarea, select, [contenteditable='true']\", # input element selector\n    default_focus_classes:tuple[str, ...]=('ring-2', 'ring-primary'), # focus ring classes\n    scroll_behavior:str='smooth', # scroll behavior\n    scroll_block:str='nearest', # scroll block alignment\n)-&gt;str: # all utility functions combined\n\nGenerate all JavaScript utility functions.\n\n# Test combined utilities\nresult = js_all_utils()\nassert \"isInputFocused\" in result\nassert \"addFocusRing\" in result\nassert \"scrollToElement\" in result\nassert \"updateHiddenInput\" in result\nassert \"triggerClick\" in result\nassert \"getDataAttributes\" in result\nassert \"getModifiers\" in result",
    "crumbs": [
      "js",
      "JavaScript Utilities"
    ]
  },
  {
    "objectID": "htmx/buttons.html",
    "href": "htmx/buttons.html",
    "title": "Action Buttons",
    "section": "",
    "text": "Build HTMX trigger expressions for keyboard events.\nNote: These triggers are only used when use_htmx_triggers=True. By default, buttons are triggered programmatically by JavaScript via triggerClick(), which respects zone and mode restrictions.\n\nsource\n\n\n\ndef build_htmx_trigger(\n    key:str, # JavaScript key name\n    modifiers:frozenset[str]=frozenset(), # modifier keys\n    input_selector:str='input, textarea, select, [contenteditable]', # input elements to exclude\n)-&gt;str: # HTMX trigger expression\n\nBuild HTMX trigger expression for keyboard event.\n\n# Test trigger expressions\n# Simple key\ntrigger = build_htmx_trigger(\" \")\nassert \"key==' '\" in trigger\nassert \"from:body\" in trigger\n\n# With modifiers\ntrigger = build_htmx_trigger(\"ArrowUp\", frozenset({\"shift\"}))\nassert \"key=='ArrowUp'\" in trigger\nassert \"shiftKey\" in trigger\n\n# Multiple modifiers\ntrigger = build_htmx_trigger(\"s\", frozenset({\"ctrl\", \"shift\"}))\nassert \"ctrlKey\" in trigger\nassert \"shiftKey\" in trigger",
    "crumbs": [
      "htmx",
      "Action Buttons"
    ]
  },
  {
    "objectID": "htmx/buttons.html#htmx-trigger-expression-builder",
    "href": "htmx/buttons.html#htmx-trigger-expression-builder",
    "title": "Action Buttons",
    "section": "",
    "text": "Build HTMX trigger expressions for keyboard events.\nNote: These triggers are only used when use_htmx_triggers=True. By default, buttons are triggered programmatically by JavaScript via triggerClick(), which respects zone and mode restrictions.\n\nsource\n\n\n\ndef build_htmx_trigger(\n    key:str, # JavaScript key name\n    modifiers:frozenset[str]=frozenset(), # modifier keys\n    input_selector:str='input, textarea, select, [contenteditable]', # input elements to exclude\n)-&gt;str: # HTMX trigger expression\n\nBuild HTMX trigger expression for keyboard event.\n\n# Test trigger expressions\n# Simple key\ntrigger = build_htmx_trigger(\" \")\nassert \"key==' '\" in trigger\nassert \"from:body\" in trigger\n\n# With modifiers\ntrigger = build_htmx_trigger(\"ArrowUp\", frozenset({\"shift\"}))\nassert \"key=='ArrowUp'\" in trigger\nassert \"shiftKey\" in trigger\n\n# Multiple modifiers\ntrigger = build_htmx_trigger(\"s\", frozenset({\"ctrl\", \"shift\"}))\nassert \"ctrlKey\" in trigger\nassert \"shiftKey\" in trigger",
    "crumbs": [
      "htmx",
      "Action Buttons"
    ]
  },
  {
    "objectID": "htmx/buttons.html#single-action-button",
    "href": "htmx/buttons.html#single-action-button",
    "title": "Action Buttons",
    "section": "Single Action Button",
    "text": "Single Action Button\n\nsource\n\nrender_action_button\n\ndef render_action_button(\n    action:KeyAction, # the action configuration\n    url:str, # POST URL for the action\n    target:str, # HTMX target selector\n    include:str='', # hx-include selector\n    swap:str='outerHTML', # hx-swap value\n    vals:dict | None=None, # hx-vals dictionary (JSON values to include in request)\n    use_htmx_trigger:bool=False, # use hx-trigger (False = JS triggerClick only)\n    input_selector:str='input, textarea, select, [contenteditable]', # inputs to exclude from trigger\n)-&gt;Button | None: # hidden button or None if not HTMX action\n\nRender a hidden HTMX button for a keyboard action.\n\n# Test action button - default (no hx-trigger, JS handles triggering)\nfrom fasthtml.common import to_xml\n\naction = KeyAction(\n    key=\" \",\n    htmx_trigger=\"toggle-btn\",\n    description=\"Toggle\"\n)\n\nbtn = render_action_button(\n    action,\n    url=\"/toggle\",\n    target=\"#list\",\n    include=\"#job-id\"\n)\n\nassert btn is not None\nhtml = to_xml(btn)\nassert 'id=\"toggle-btn\"' in html\nassert 'hx-post=\"/toggle\"' in html\nassert 'hx-target=\"#list\"' in html\n# No hx-trigger by default - JavaScript handles triggering\nassert 'hx-trigger' not in html\n# No hx-vals by default\nassert 'hx-vals' not in html\n\n\n# Test with hx-trigger enabled\nbtn_with_trigger = render_action_button(\n    action,\n    url=\"/toggle\",\n    target=\"#list\",\n    use_htmx_trigger=True\n)\nhtml = to_xml(btn_with_trigger)\nassert 'hx-trigger=' in html\nassert \"key==' '\" in html\n\n# Test with vals parameter\nbtn_with_vals = render_action_button(\n    action,\n    url=\"/reorder\",\n    target=\"#queue\",\n    vals={\"direction\": \"up\"}\n)\nhtml = to_xml(btn_with_vals)\nassert 'hx-vals=' in html\nassert '\"direction\"' in html\nassert '\"up\"' in html\n\n# Non-HTMX action returns None\njs_action = KeyAction(\n    key=\"Enter\",\n    js_callback=\"doSomething\"\n)\n\nbtn = render_action_button(js_action, \"/unused\", \"#unused\")\nassert btn is None",
    "crumbs": [
      "htmx",
      "Action Buttons"
    ]
  },
  {
    "objectID": "htmx/buttons.html#action-buttons-container",
    "href": "htmx/buttons.html#action-buttons-container",
    "title": "Action Buttons",
    "section": "Action Buttons Container",
    "text": "Action Buttons Container\n\nsource\n\nrender_action_buttons\n\ndef render_action_buttons(\n    manager:ZoneManager, # the zone manager configuration\n    url_map:dict[str, str], # action button ID -&gt; URL\n    target_map:dict[str, str], # action button ID -&gt; target selector\n    include_map:dict[str, str] | None=None, # action button ID -&gt; include selector\n    swap_map:dict[str, str] | None=None, # action button ID -&gt; swap value\n    vals_map:dict[str, dict] | None=None, # action button ID -&gt; hx-vals dict\n    use_htmx_triggers:bool=False, # use hx-trigger (False = JS triggerClick only)\n    container_id:str='kb-action-buttons', # container element ID\n)-&gt;Div: # container with all action buttons\n\nRender all hidden HTMX action buttons for keyboard navigation.\n\n# Test action buttons container - default (no hx-trigger)\nfrom cjm_fasthtml_keyboard_navigation.core.focus_zone import FocusZone\n\nzone = FocusZone(id=\"list\", item_selector=\"li\")\n\nmanager = ZoneManager(\n    zones=(zone,),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"toggle-btn\"),\n        KeyAction(key=\"Delete\", htmx_trigger=\"delete-btn\"),\n        KeyAction(key=\"Enter\", js_callback=\"edit\"),  # No button for this\n    )\n)\n\ncontainer = render_action_buttons(\n    manager,\n    url_map={\n        \"toggle-btn\": \"/toggle\",\n        \"delete-btn\": \"/delete\"\n    },\n    target_map={\n        \"toggle-btn\": \"#list\",\n        \"delete-btn\": \"#list\"\n    }\n)\n\nhtml = to_xml(container)\nassert 'id=\"kb-action-buttons\"' in html\nassert 'id=\"toggle-btn\"' in html\nassert 'id=\"delete-btn\"' in html\n# Should not have hx-trigger by default\nassert 'hx-trigger' not in html\n# Should not have a button for js_callback action\nassert html.count('&lt;button') == 2\n\n\n# Test with vals_map\nmanager_with_reorder = ZoneManager(\n    zones=(zone,),\n    actions=(\n        KeyAction(key=\"ArrowUp\", modifiers=frozenset({\"shift\"}), htmx_trigger=\"reorder-up-btn\"),\n        KeyAction(key=\"ArrowDown\", modifiers=frozenset({\"shift\"}), htmx_trigger=\"reorder-down-btn\"),\n    )\n)\n\ncontainer_with_vals = render_action_buttons(\n    manager_with_reorder,\n    url_map={\n        \"reorder-up-btn\": \"/reorder\",\n        \"reorder-down-btn\": \"/reorder\"\n    },\n    target_map={\n        \"reorder-up-btn\": \"#queue\",\n        \"reorder-down-btn\": \"#queue\"\n    },\n    vals_map={\n        \"reorder-up-btn\": {\"direction\": \"up\"},\n        \"reorder-down-btn\": {\"direction\": \"down\"}\n    }\n)\n\nhtml = to_xml(container_with_vals)\nassert 'id=\"reorder-up-btn\"' in html\nassert 'id=\"reorder-down-btn\"' in html\nassert '\"direction\": \"up\"' in html\nassert '\"direction\": \"down\"' in html",
    "crumbs": [
      "htmx",
      "Action Buttons"
    ]
  },
  {
    "objectID": "core/modes.html",
    "href": "core/modes.html",
    "title": "Keyboard Modes",
    "section": "",
    "text": "A named state that changes keyboard behavior. Modes can override navigation patterns, have their own key bindings, and trigger callbacks on entry/exit.\n\nsource\n\n\n\ndef KeyboardMode(\n    name:str, enter_key:Optional[str]=None, enter_modifiers:frozenset[str]=&lt;factory&gt;, exit_key:str='Escape',\n    exit_modifiers:frozenset[str]=&lt;factory&gt;, zone_ids:Optional[tuple[str, ...]]=None,\n    navigation_override:Optional[NavigationPattern]=None, on_enter:Optional[str]=None, on_exit:Optional[str]=None,\n    indicator_text:Optional[str]=None, exit_on_zone_change:bool=True\n)-&gt;None:\n\nA named mode that changes keyboard behavior.\n\n# Test basic KeyboardMode\nmode = KeyboardMode(\n    name=\"split\",\n    enter_key=\"Enter\",\n    exit_key=\"Escape\",\n    zone_ids=(\"card-list\",),\n    on_enter=\"enterSplitMode\",\n    on_exit=\"exitSplitMode\",\n    indicator_text=\"Split Mode\"\n)\n\nassert mode.name == \"split\"\nassert mode.is_available_in_zone(\"card-list\") == True\nassert mode.is_available_in_zone(\"other-zone\") == False\n\nconfig = mode.to_js_config()\nassert config[\"name\"] == \"split\"\nassert config[\"enterKey\"] == \"Enter\"\nassert config[\"zoneIds\"] == [\"card-list\"]\n\n\n# Test mode available in all zones\nglobal_mode = KeyboardMode(\n    name=\"help\",\n    enter_key=\"?\",\n    zone_ids=None  # available everywhere\n)\n\nassert global_mode.is_available_in_zone(\"any-zone\") == True\nassert global_mode.to_js_config()[\"zoneIds\"] is None",
    "crumbs": [
      "core",
      "Keyboard Modes"
    ]
  },
  {
    "objectID": "core/modes.html#keyboardmode",
    "href": "core/modes.html#keyboardmode",
    "title": "Keyboard Modes",
    "section": "",
    "text": "A named state that changes keyboard behavior. Modes can override navigation patterns, have their own key bindings, and trigger callbacks on entry/exit.\n\nsource\n\n\n\ndef KeyboardMode(\n    name:str, enter_key:Optional[str]=None, enter_modifiers:frozenset[str]=&lt;factory&gt;, exit_key:str='Escape',\n    exit_modifiers:frozenset[str]=&lt;factory&gt;, zone_ids:Optional[tuple[str, ...]]=None,\n    navigation_override:Optional[NavigationPattern]=None, on_enter:Optional[str]=None, on_exit:Optional[str]=None,\n    indicator_text:Optional[str]=None, exit_on_zone_change:bool=True\n)-&gt;None:\n\nA named mode that changes keyboard behavior.\n\n# Test basic KeyboardMode\nmode = KeyboardMode(\n    name=\"split\",\n    enter_key=\"Enter\",\n    exit_key=\"Escape\",\n    zone_ids=(\"card-list\",),\n    on_enter=\"enterSplitMode\",\n    on_exit=\"exitSplitMode\",\n    indicator_text=\"Split Mode\"\n)\n\nassert mode.name == \"split\"\nassert mode.is_available_in_zone(\"card-list\") == True\nassert mode.is_available_in_zone(\"other-zone\") == False\n\nconfig = mode.to_js_config()\nassert config[\"name\"] == \"split\"\nassert config[\"enterKey\"] == \"Enter\"\nassert config[\"zoneIds\"] == [\"card-list\"]\n\n\n# Test mode available in all zones\nglobal_mode = KeyboardMode(\n    name=\"help\",\n    enter_key=\"?\",\n    zone_ids=None  # available everywhere\n)\n\nassert global_mode.is_available_in_zone(\"any-zone\") == True\nassert global_mode.to_js_config()[\"zoneIds\"] is None",
    "crumbs": [
      "core",
      "Keyboard Modes"
    ]
  },
  {
    "objectID": "core/modes.html#default-navigation-mode",
    "href": "core/modes.html#default-navigation-mode",
    "title": "Keyboard Modes",
    "section": "Default Navigation Mode",
    "text": "Default Navigation Mode\nThe default mode that’s always active when no other mode is entered.\n\n# Test default mode\nassert NAVIGATION_MODE.name == \"navigation\"\nassert NAVIGATION_MODE.enter_key is None\nassert NAVIGATION_MODE.is_available_in_zone(\"any\") == True",
    "crumbs": [
      "core",
      "Keyboard Modes"
    ]
  },
  {
    "objectID": "core/modes.html#example-modes",
    "href": "core/modes.html#example-modes",
    "title": "Keyboard Modes",
    "section": "Example Modes",
    "text": "Example Modes\nCommon mode patterns for reference.\n\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import LinearHorizontal\n\n# Split mode for text segmentation (Phase 2 style)\nsplit_mode_example = KeyboardMode(\n    name=\"split\",\n    enter_key=\"Enter\",\n    exit_key=\"Escape\",\n    navigation_override=LinearHorizontal(),  # left/right for caret\n    on_enter=\"enterSplitMode\",\n    on_exit=\"exitSplitMode\",\n    indicator_text=\"Split Mode\"\n)\n\n# Audition mode for audio preview (Phase 3 style)\naudition_mode_example = KeyboardMode(\n    name=\"audition\",\n    enter_key=None,  # entered by switching to VAD zone\n    zone_ids=(\"vad-timeline\",),\n    on_enter=\"startAudition\",\n    indicator_text=\"Audition\"\n)\n\n# Edit mode for inline editing\nedit_mode_example = KeyboardMode(\n    name=\"edit\",\n    enter_key=\"e\",\n    exit_key=\"Escape\",\n    on_enter=\"startEditing\",\n    on_exit=\"finishEditing\",\n    indicator_text=\"Edit\"\n)",
    "crumbs": [
      "core",
      "Keyboard Modes"
    ]
  },
  {
    "objectID": "core/key_mapping.html",
    "href": "core/key_mapping.html",
    "title": "Key Mapping",
    "section": "",
    "text": "Maps physical keys to navigation directions, allowing customization of navigation keys.\n\nsource\n\n\n\ndef KeyMapping(\n    up:tuple[str, ...]=('ArrowUp',), down:tuple[str, ...]=('ArrowDown',), left:tuple[str, ...]=('ArrowLeft',),\n    right:tuple[str, ...]=('ArrowRight',)\n)-&gt;None:\n\nMaps physical keys to navigation directions.\n\n# Test KeyMapping basics\nkm = KeyMapping()\nassert km.get_direction(\"ArrowUp\") == \"up\"\nassert km.get_direction(\"ArrowDown\") == \"down\"\nassert km.get_direction(\"ArrowLeft\") == \"left\"\nassert km.get_direction(\"ArrowRight\") == \"right\"\nassert km.get_direction(\"x\") is None",
    "crumbs": [
      "core",
      "Key Mapping"
    ]
  },
  {
    "objectID": "core/key_mapping.html#keymapping",
    "href": "core/key_mapping.html#keymapping",
    "title": "Key Mapping",
    "section": "",
    "text": "Maps physical keys to navigation directions, allowing customization of navigation keys.\n\nsource\n\n\n\ndef KeyMapping(\n    up:tuple[str, ...]=('ArrowUp',), down:tuple[str, ...]=('ArrowDown',), left:tuple[str, ...]=('ArrowLeft',),\n    right:tuple[str, ...]=('ArrowRight',)\n)-&gt;None:\n\nMaps physical keys to navigation directions.\n\n# Test KeyMapping basics\nkm = KeyMapping()\nassert km.get_direction(\"ArrowUp\") == \"up\"\nassert km.get_direction(\"ArrowDown\") == \"down\"\nassert km.get_direction(\"ArrowLeft\") == \"left\"\nassert km.get_direction(\"ArrowRight\") == \"right\"\nassert km.get_direction(\"x\") is None",
    "crumbs": [
      "core",
      "Key Mapping"
    ]
  },
  {
    "objectID": "core/key_mapping.html#preset-key-mappings",
    "href": "core/key_mapping.html#preset-key-mappings",
    "title": "Key Mapping",
    "section": "Preset Key Mappings",
    "text": "Preset Key Mappings\nCommon key mapping presets for different use cases.\n\n# Test presets\nassert WASD_KEYS.get_direction(\"w\") == \"up\"\nassert WASD_KEYS.get_direction(\"W\") == \"up\"\nassert VIM_KEYS.get_direction(\"j\") == \"down\"\nassert VIM_KEYS.get_direction(\"k\") == \"up\"\nassert NUMPAD_KEYS.get_direction(\"8\") == \"up\"\nassert ARROWS_AND_WASD.get_direction(\"ArrowUp\") == \"up\"\nassert ARROWS_AND_WASD.get_direction(\"w\") == \"up\"",
    "crumbs": [
      "core",
      "Key Mapping"
    ]
  },
  {
    "objectID": "core/key_mapping.html#key-display-formatting",
    "href": "core/key_mapping.html#key-display-formatting",
    "title": "Key Mapping",
    "section": "Key Display Formatting",
    "text": "Key Display Formatting\nUtilities for formatting keys for user display.\n\nsource\n\nformat_key_for_display\n\ndef format_key_for_display(\n    key:str, # the JavaScript key name\n)-&gt;str: # human-readable display string\n\nFormat a key name for user display.\n\nsource\n\n\nformat_key_combo\n\ndef format_key_combo(\n    key:str, # the main key\n    modifiers:frozenset[str]=frozenset(), # modifier keys (shift, ctrl, alt, meta)\n)-&gt;str: # formatted string like \"Ctrl+Shift+A\"\n\nFormat a key combination for display.\n\n# Test display formatting\nassert format_key_for_display(\"ArrowUp\") == \"↑\"\nassert format_key_for_display(\" \") == \"Space\"\nassert format_key_for_display(\"a\") == \"a\"  # passthrough\n\nassert format_key_combo(\"ArrowUp\") == \"↑\"\nassert format_key_combo(\"ArrowUp\", frozenset({\"shift\"})) == \"Shift+↑\"\nassert format_key_combo(\"a\", frozenset({\"ctrl\", \"shift\"})) == \"Ctrl+Shift+a\"",
    "crumbs": [
      "core",
      "Key Mapping"
    ]
  },
  {
    "objectID": "core/focus_zone.html",
    "href": "core/focus_zone.html",
    "title": "Focus Zone",
    "section": "",
    "text": "A container that can receive focus and contains navigable items. Each zone tracks its own focus state and can have independent navigation patterns.\n\nsource\n\n\n\ndef FocusZone(\n    id:str, item_selector:Optional[str]=None, navigation:Union[NavigationPattern, LinearVertical]=&lt;factory&gt;,\n    navigation_throttle_ms:int=0, item_focus_classes:tuple[str, ...]=('ring-2', 'ring-primary'),\n    item_focus_attribute:str='data-focused',\n    zone_focus_classes:tuple[str, ...]=('ring-2', 'ring-primary', 'inset-ring-2'),\n    data_attributes:tuple[str, ...]=(), on_focus_change:Optional[str]=None, on_navigate:Optional[str]=None,\n    on_zone_enter:Optional[str]=None, on_zone_leave:Optional[str]=None, scroll_behavior:str='smooth',\n    scroll_block:str='nearest', hidden_input_prefix:str='', initial_index:int=0\n)-&gt;None:\n\nA focusable container with navigable items.\n\n# Test FocusZone basics\nzone = FocusZone(\n    id=\"source-browser\",\n    item_selector=\"tr[data-selectable='true']\",\n    data_attributes=(\"job-id\", \"plugin-name\"),\n    on_focus_change=\"updatePreview\"\n)\n\nassert zone.id == \"source-browser\"\nassert zone.has_items() == True\nassert zone.get_hidden_input_id(\"job-id\") == \"source-browser-job-id\"\n\n# Test to_js_config\nconfig = zone.to_js_config()\nassert config[\"id\"] == \"source-browser\"\nassert config[\"itemSelector\"] == \"tr[data-selectable='true']\"\nassert config[\"onFocusChange\"] == \"updatePreview\"\n\n\n# Test scroll-only zone\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import ScrollOnly\n\npreview_zone = FocusZone(\n    id=\"preview-panel\",\n    item_selector=None,\n    navigation=ScrollOnly()\n)\n\nassert preview_zone.has_items() == False\nassert preview_zone.navigation.name == \"scroll_only\"\n\n\n# Test with custom hidden input prefix\nzone_with_prefix = FocusZone(\n    id=\"my-zone\",\n    hidden_input_prefix=\"kb\",\n    data_attributes=(\"file-path\",)\n)\n\nassert zone_with_prefix.get_hidden_input_id(\"file-path\") == \"kb-file-path\"",
    "crumbs": [
      "core",
      "Focus Zone"
    ]
  },
  {
    "objectID": "core/focus_zone.html#focuszone",
    "href": "core/focus_zone.html#focuszone",
    "title": "Focus Zone",
    "section": "",
    "text": "A container that can receive focus and contains navigable items. Each zone tracks its own focus state and can have independent navigation patterns.\n\nsource\n\n\n\ndef FocusZone(\n    id:str, item_selector:Optional[str]=None, navigation:Union[NavigationPattern, LinearVertical]=&lt;factory&gt;,\n    navigation_throttle_ms:int=0, item_focus_classes:tuple[str, ...]=('ring-2', 'ring-primary'),\n    item_focus_attribute:str='data-focused',\n    zone_focus_classes:tuple[str, ...]=('ring-2', 'ring-primary', 'inset-ring-2'),\n    data_attributes:tuple[str, ...]=(), on_focus_change:Optional[str]=None, on_navigate:Optional[str]=None,\n    on_zone_enter:Optional[str]=None, on_zone_leave:Optional[str]=None, scroll_behavior:str='smooth',\n    scroll_block:str='nearest', hidden_input_prefix:str='', initial_index:int=0\n)-&gt;None:\n\nA focusable container with navigable items.\n\n# Test FocusZone basics\nzone = FocusZone(\n    id=\"source-browser\",\n    item_selector=\"tr[data-selectable='true']\",\n    data_attributes=(\"job-id\", \"plugin-name\"),\n    on_focus_change=\"updatePreview\"\n)\n\nassert zone.id == \"source-browser\"\nassert zone.has_items() == True\nassert zone.get_hidden_input_id(\"job-id\") == \"source-browser-job-id\"\n\n# Test to_js_config\nconfig = zone.to_js_config()\nassert config[\"id\"] == \"source-browser\"\nassert config[\"itemSelector\"] == \"tr[data-selectable='true']\"\nassert config[\"onFocusChange\"] == \"updatePreview\"\n\n\n# Test scroll-only zone\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import ScrollOnly\n\npreview_zone = FocusZone(\n    id=\"preview-panel\",\n    item_selector=None,\n    navigation=ScrollOnly()\n)\n\nassert preview_zone.has_items() == False\nassert preview_zone.navigation.name == \"scroll_only\"\n\n\n# Test with custom hidden input prefix\nzone_with_prefix = FocusZone(\n    id=\"my-zone\",\n    hidden_input_prefix=\"kb\",\n    data_attributes=(\"file-path\",)\n)\n\nassert zone_with_prefix.get_hidden_input_id(\"file-path\") == \"kb-file-path\"",
    "crumbs": [
      "core",
      "Focus Zone"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cjm-fasthtml-keyboard-navigation",
    "section": "",
    "text": "pip install cjm_fasthtml_keyboard_navigation",
    "crumbs": [
      "cjm-fasthtml-keyboard-navigation"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cjm-fasthtml-keyboard-navigation",
    "section": "",
    "text": "pip install cjm_fasthtml_keyboard_navigation",
    "crumbs": [
      "cjm-fasthtml-keyboard-navigation"
    ]
  },
  {
    "objectID": "index.html#project-structure",
    "href": "index.html#project-structure",
    "title": "cjm-fasthtml-keyboard-navigation",
    "section": "Project Structure",
    "text": "Project Structure\nnbs/\n├── components/ (2)\n│   ├── hints.ipynb   # Components for displaying keyboard shortcut hints to users.\n│   └── system.ipynb  # High-level API for rendering complete keyboard navigation systems.\n├── core/ (6)\n│   ├── actions.ipynb      # Declarative keyboard action bindings supporting HTMX triggers and JS callbacks.\n│   ├── focus_zone.ipynb   # Configuration for focusable containers with navigable items.\n│   ├── key_mapping.ipynb  # Configurable key-to-direction mappings for customizable navigation keys.\n│   ├── manager.ipynb      # Coordinates keyboard navigation across multiple zones, modes, and actions.\n│   ├── modes.ipynb        # Configuration for keyboard modes that change navigation and action behavior.\n│   └── navigation.ipynb   # Protocols and implementations for keyboard navigation within focus zones.\n├── htmx/ (2)\n│   ├── buttons.ipynb  # Generate hidden HTMX action buttons triggered by keyboard events.\n│   └── inputs.ipynb   # Generate hidden inputs for HTMX integration with keyboard navigation.\n└── js/ (2)\n    ├── generators.ipynb  # Generate complete keyboard navigation JavaScript from configuration.\n    └── utils.ipynb       # Core JavaScript utility generators for keyboard navigation.\nTotal: 12 notebooks across 4 directories",
    "crumbs": [
      "cjm-fasthtml-keyboard-navigation"
    ]
  },
  {
    "objectID": "index.html#module-dependencies",
    "href": "index.html#module-dependencies",
    "title": "cjm-fasthtml-keyboard-navigation",
    "section": "Module Dependencies",
    "text": "Module Dependencies\ngraph LR\n    components_hints[components.hints&lt;br/&gt;Keyboard Hints]\n    components_system[components.system&lt;br/&gt;Keyboard System]\n    core_actions[core.actions&lt;br/&gt;Key Actions]\n    core_focus_zone[core.focus_zone&lt;br/&gt;Focus Zone]\n    core_key_mapping[core.key_mapping&lt;br/&gt;Key Mapping]\n    core_manager[core.manager&lt;br/&gt;Zone Manager]\n    core_modes[core.modes&lt;br/&gt;Keyboard Modes]\n    core_navigation[core.navigation&lt;br/&gt;Navigation Patterns]\n    htmx_buttons[htmx.buttons&lt;br/&gt;Action Buttons]\n    htmx_inputs[htmx.inputs&lt;br/&gt;Hidden Inputs]\n    js_generators[js.generators&lt;br/&gt;Script Generators]\n    js_utils[js.utils&lt;br/&gt;JavaScript Utilities]\n\n    components_hints --&gt; core_focus_zone\n    components_hints --&gt; core_manager\n    components_hints --&gt; core_actions\n    components_system --&gt; js_generators\n    components_system --&gt; htmx_inputs\n    components_system --&gt; core_manager\n    components_system --&gt; htmx_buttons\n    components_system --&gt; core_actions\n    components_system --&gt; components_hints\n    components_system --&gt; core_focus_zone\n    core_actions --&gt; core_key_mapping\n    core_focus_zone --&gt; core_navigation\n    core_manager --&gt; core_key_mapping\n    core_manager --&gt; core_navigation\n    core_manager --&gt; core_modes\n    core_manager --&gt; core_actions\n    core_manager --&gt; core_focus_zone\n    core_modes --&gt; core_navigation\n    htmx_buttons --&gt; core_manager\n    htmx_buttons --&gt; core_actions\n    htmx_buttons --&gt; core_focus_zone\n    htmx_inputs --&gt; core_manager\n    htmx_inputs --&gt; core_focus_zone\n    js_generators --&gt; js_utils\n    js_generators --&gt; core_manager\n    js_generators --&gt; core_actions\n    js_generators --&gt; core_focus_zone\n27 cross-module dependencies detected",
    "crumbs": [
      "cjm-fasthtml-keyboard-navigation"
    ]
  },
  {
    "objectID": "index.html#cli-reference",
    "href": "index.html#cli-reference",
    "title": "cjm-fasthtml-keyboard-navigation",
    "section": "CLI Reference",
    "text": "CLI Reference\nNo CLI commands found in this project.",
    "crumbs": [
      "cjm-fasthtml-keyboard-navigation"
    ]
  },
  {
    "objectID": "index.html#module-overview",
    "href": "index.html#module-overview",
    "title": "cjm-fasthtml-keyboard-navigation",
    "section": "Module Overview",
    "text": "Module Overview\nDetailed documentation for each module in the project:\n\nKey Actions (actions.ipynb)\n\nDeclarative keyboard action bindings supporting HTMX triggers and JS callbacks.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.core.actions import (\n    KeyAction\n)\n\n\nClasses\n@dataclass\nclass KeyAction:\n    \"A keyboard shortcut binding.\"\n    \n    key: str  # JavaScript key name (e.g., \"Enter\", \" \", \"ArrowUp\")\n    modifiers: frozenset[str] = field(...)\n    htmx_trigger: Optional[str]  # ID of hidden button to click\n    js_callback: Optional[str]  # JS function name to call\n    mode_enter: Optional[str]  # mode name to enter\n    mode_exit: bool = False  # exit current mode (return to default)\n    prevent_default: bool = True  # call e.preventDefault()\n    stop_propagation: bool = False  # call e.stopPropagation()\n    zone_ids: Optional[tuple[str, ...]]  # only in these zones (None = all)\n    mode_names: Optional[tuple[str, ...]]  # only in these modes (None = all)\n    not_modes: Optional[tuple[str, ...]]  # not in these modes\n    custom_condition: Optional[str]  # raw JS expression for additional conditions\n    description: str = ''  # human-readable description for hints\n    hint_group: str = 'General'  # grouping for keyboard hints display\n    show_in_hints: bool = True  # whether to show in keyboard hints\n    \n    def matches_context(\n            self,\n            zone_id: str,  # current active zone\n            mode_name: str  # current mode\n        ) -&gt; bool:         # True if action is valid in this context\n        \"Check if action is valid for given zone and mode.\"\n    \n    def get_display_key(self) -&gt; str: # formatted key combo for display\n            \"\"\"Get formatted key combination for display.\"\"\"\n            return format_key_combo(self.key, self.modifiers)\n    \n        def to_js_config(self) -&gt; dict: # JavaScript-compatible configuration\n        \"Get formatted key combination for display.\"\n    \n    def to_js_config(self) -&gt; dict: # JavaScript-compatible configuration\n            \"\"\"Convert to JavaScript configuration object.\"\"\"\n            return {\n                \"key\": self.key,\n        \"Convert to JavaScript configuration object.\"\n\n\n\nAction Buttons (buttons.ipynb)\n\nGenerate hidden HTMX action buttons triggered by keyboard events.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.htmx.buttons import (\n    build_htmx_trigger,\n    render_action_button,\n    render_action_buttons\n)\n\n\nFunctions\ndef build_htmx_trigger(\n    key: str,                           # JavaScript key name\n    modifiers: frozenset[str] = frozenset(),  # modifier keys\n    input_selector: str = \"input, textarea, select, [contenteditable]\"  # input elements to exclude\n) -&gt; str:                               # HTMX trigger expression\n    \"Build HTMX trigger expression for keyboard event.\"\ndef render_action_button(\n    action: KeyAction,           # the action configuration\n    url: str,                    # POST URL for the action\n    target: str,                 # HTMX target selector\n    include: str = \"\",           # hx-include selector\n    swap: str = \"outerHTML\",     # hx-swap value\n    vals: dict | None = None,    # hx-vals dictionary (JSON values to include in request)\n    use_htmx_trigger: bool = False,  # use hx-trigger (False = JS triggerClick only)\n    input_selector: str = \"input, textarea, select, [contenteditable]\"  # inputs to exclude from trigger\n) -&gt; Button | None:              # hidden button or None if not HTMX action\n    \"Render a hidden HTMX button for a keyboard action.\"\ndef render_action_buttons(\n    manager: ZoneManager,                         # the zone manager configuration\n    url_map: dict[str, str],                      # action button ID -&gt; URL\n    target_map: dict[str, str],                   # action button ID -&gt; target selector\n    include_map: dict[str, str] | None = None,    # action button ID -&gt; include selector\n    swap_map: dict[str, str] | None = None,       # action button ID -&gt; swap value\n    vals_map: dict[str, dict] | None = None,      # action button ID -&gt; hx-vals dict\n    use_htmx_triggers: bool = False,              # use hx-trigger (False = JS triggerClick only)\n    container_id: str = \"kb-action-buttons\"       # container element ID\n) -&gt; Div:                                         # container with all action buttons\n    \"Render all hidden HTMX action buttons for keyboard navigation.\"\n\n\n\nFocus Zone (focus_zone.ipynb)\n\nConfiguration for focusable containers with navigable items.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.core.focus_zone import (\n    FocusZone\n)\n\n\nClasses\n@dataclass\nclass FocusZone:\n    \"A focusable container with navigable items.\"\n    \n    id: str  # HTML element ID of the container\n    item_selector: Optional[str]  # CSS selector for items (None = scroll only)\n    navigation: Union[NavigationPattern, LinearVertical] = field(...)\n    navigation_throttle_ms: int = 0  # minimum ms between navigation events (0 = no throttle)\n    item_focus_classes: tuple[str, ...] = (str(ring(2)), str(ring_dui.primary))  # CSS classes for focused item\n    item_focus_attribute: str = 'data-focused'  # attribute set to \"true\" on focused item\n    zone_focus_classes: tuple[str, ...] = (str(ring(2)), str(ring_dui.primary), str(inset_ring(2)))\n    data_attributes: tuple[str, ...] = ()  # data attributes to extract from focused item\n    on_focus_change: Optional[str]  # called when focused item changes\n    on_navigate: Optional[str]  # called on any navigation (for side effects like audition)\n    on_zone_enter: Optional[str]  # called when zone becomes active\n    on_zone_leave: Optional[str]  # called when zone loses focus\n    scroll_behavior: str = 'smooth'  # \"smooth\" or \"auto\"\n    scroll_block: str = 'nearest'  # \"start\", \"center\", \"end\", \"nearest\"\n    hidden_input_prefix: str = ''  # prefix for auto-generated hidden input IDs\n    initial_index: int = 0  # initial focused item index\n    \n    def has_items(self) -&gt; bool: # True if zone has selectable items\n            \"\"\"Check if zone has selectable items.\"\"\"\n            return self.item_selector is not None\n    \n        def get_hidden_input_id(\n            self,\n            attr: str  # the data attribute name\n        ) -&gt; str:      # the hidden input element ID\n        \"Check if zone has selectable items.\"\n    \n    def get_hidden_input_id(\n            self,\n            attr: str  # the data attribute name\n        ) -&gt; str:      # the hidden input element ID\n        \"Get the hidden input ID for a data attribute.\"\n    \n    def to_js_config(self) -&gt; dict: # JavaScript-compatible configuration\n            \"\"\"Convert to JavaScript configuration object.\"\"\"\n            return {\n                \"id\": self.id,\n        \"Convert to JavaScript configuration object.\"\n\n\n\nScript Generators (generators.ipynb)\n\nGenerate complete keyboard navigation JavaScript from configuration.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.js.generators import (\n    js_zone_state,\n    js_focus_management,\n    js_zone_switching,\n    js_navigation,\n    js_mode_management,\n    js_action_dispatch,\n    js_keyboard_handler,\n    js_state_notification,\n    js_initialization,\n    js_global_api,\n    generate_keyboard_script\n)\n\n\nFunctions\ndef js_zone_state() -&gt; str: # JavaScript state and getter/setter code\n    \"Generate JavaScript code for zone state management.\"\ndef js_focus_management() -&gt; str: # JavaScript focus management code\n    \"Generate JavaScript code for focus management.\"\ndef js_zone_switching() -&gt; str: # JavaScript zone switching code\n    \"Generate JavaScript code for zone switching.\"\ndef js_navigation() -&gt; str: # JavaScript navigation code\n    \"\"\"Generate JavaScript code for item navigation.\"\"\"\n    return '''\n// === Navigation ===\n// Track last navigation time per zone for throttling\nlet lastNavigationTime = {};\n\nfunction getNavigationPattern(zoneId) {\n    // Check if mode overrides navigation\n    const modeConfig = getModeConfig(currentMode);\n    if (modeConfig && modeConfig.navigationOverride) {\n        return modeConfig.navigationOverride;\n    }\n    // Use zone's pattern\n    const zone = getZoneConfig(zoneId);\n    return zone ? zone.navigationPattern : 'linear_vertical';\n    \"Generate JavaScript code for item navigation.\"\ndef js_mode_management() -&gt; str: # JavaScript mode management code\n    \"Generate JavaScript code for mode management.\"\ndef js_action_dispatch() -&gt; str: # JavaScript action dispatch code\n    \"Generate JavaScript code for action dispatch.\"\ndef js_keyboard_handler() -&gt; str: # JavaScript keyboard handler code\n    \"Generate JavaScript code for keyboard event handling.\"\ndef js_state_notification() -&gt; str: # JavaScript state notification code\n    \"Generate JavaScript code for state change notification.\"\ndef js_initialization() -&gt; str: # JavaScript initialization code\n    \"Generate JavaScript code for initialization with focus recovery.\"\ndef js_global_api() -&gt; str:  # JavaScript global API exposure code\n    \"Generate JavaScript code to expose mode control functions globally.\"\ndef generate_keyboard_script(\n    manager: ZoneManager  # the zone manager configuration\n) -&gt; str:                 # complete JavaScript code wrapped in IIFE\n    \"Generate complete keyboard navigation JavaScript from ZoneManager.\"\n\n\n\nKeyboard Hints (hints.ipynb)\n\nComponents for displaying keyboard shortcut hints to users.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.components.hints import (\n    NAV_ICON_MAP,\n    KEY_ICON_MAP,\n    get_key_icon,\n    render_hint_badge,\n    create_nav_icon_hint,\n    create_modifier_key_hint,\n    render_hint_group,\n    group_actions_by_hint_group,\n    render_hints_from_actions,\n    render_keyboard_hints\n)\n\n\nFunctions\ndef get_key_icon(\n    key_name: str,    # key name to look up (case-insensitive)\n    size: int = 3     # icon size\n) -&gt; FT | None:       # icon component or None if no icon mapping\n    \"Get a lucide icon for a key name, if one exists.\"\ndef render_hint_badge(\n    key_display: Union[str, FT],  # formatted key string or icon component\n    description: str,              # action description\n    style: str = \"ghost\",          # badge style (ghost, outline, soft, dash)\n    auto_icon: bool = False        # auto-convert known keys to icons\n) -&gt; Div:                          # hint badge component\n    \"Render a single keyboard hint as a badge.\"\ndef create_nav_icon_hint(\n    icon_name: str,      # lucide icon name (e.g., \"arrow-down-up\")\n    description: str,    # action description\n    style: str = \"ghost\" # badge style\n) -&gt; Div:                # hint badge with icon\n    \"Create a hint badge with a lucide icon.\"\ndef create_modifier_key_hint(\n    modifier: str,       # modifier key name (e.g., \"shift\", \"ctrl\")\n    key_icon_or_text: Union[str, FT],  # the main key icon or text\n    description: str,    # action description\n    style: str = \"ghost\" # badge style\n) -&gt; Div:                # hint badge with modifier + key\n    \"Create a hint badge with a modifier key and main key.\"\ndef render_hint_group(\n    group_name: str,         # group header text\n    hints: list[tuple[str, str]],  # list of (key_display, description) tuples\n    badge_style: str = \"ghost\"     # badge style for this group\n) -&gt; Div:                    # group container with header and hints\n    \"Render a group of related keyboard hints.\"\ndef group_actions_by_hint_group(\n    actions: tuple[KeyAction, ...]  # actions to group\n) -&gt; dict[str, list[KeyAction]]:    # grouped actions\n    \"Group actions by their hint_group attribute.\"\ndef render_hints_from_actions(\n    actions: tuple[KeyAction, ...],  # actions to display hints for\n    badge_style: str = \"ghost\"       # badge style\n) -&gt; Div:                            # container with all hint groups\n    \"Render keyboard hints from action configurations.\"\ndef render_keyboard_hints(\n    manager: ZoneManager,                      # the zone manager\n    include_navigation: bool = True,           # include navigation hints\n    include_zone_switch: bool = True,          # include zone switching hints\n    badge_style: str = \"ghost\",                # badge style\n    container_id: str = \"kb-hints\",            # container element ID\n    use_icons: bool = True                     # use lucide icons for nav hints\n) -&gt; Div:                                      # complete hints component\n    \"Render complete keyboard hints for a zone manager.\"\n\n\nVariables\nNAV_ICON_MAP = {2 items}\nKEY_ICON_MAP = {9 items}\n\n\n\nHidden Inputs (inputs.ipynb)\n\nGenerate hidden inputs for HTMX integration with keyboard navigation.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.htmx.inputs import (\n    render_zone_hidden_inputs,\n    render_hidden_inputs,\n    build_include_selector,\n    build_all_zones_include_selector\n)\n\n\nFunctions\ndef render_zone_hidden_inputs(\n    zone: FocusZone  # the focus zone configuration\n) -&gt; list:           # list of Hidden input components\n    \"Render hidden inputs for a single zone's data attributes.\"\ndef render_hidden_inputs(\n    manager: ZoneManager,            # the zone manager configuration\n    include_state: bool = False,     # include state tracking inputs\n    container_id: str = \"kb-hidden-inputs\"  # container element ID\n) -&gt; Div:                            # container with all hidden inputs\n    \"\"\"\n    Render all hidden inputs for keyboard navigation.\n    \n    Deduplicates inputs by ID - zones with the same hidden_input_prefix\n    will share inputs rather than creating duplicates.\n    \"\"\"\ndef build_include_selector(\n    zone: FocusZone,              # the zone to include inputs from\n    include_state: bool = False   # include state inputs\n) -&gt; str:                         # CSS selector for hx-include\n    \"Build hx-include selector for zone's hidden inputs.\"\ndef build_all_zones_include_selector(\n    manager: ZoneManager,         # the zone manager\n    include_state: bool = False   # include state inputs\n) -&gt; str:                         # CSS selector for all zones\n    \"\"\"\n    Build hx-include selector for all zones' hidden inputs.\n    \n    Deduplicates selectors - zones with the same hidden_input_prefix\n    will only include each input once.\n    \"\"\"\n\n\n\nKey Mapping (key_mapping.ipynb)\n\nConfigurable key-to-direction mappings for customizable navigation keys.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.core.key_mapping import (\n    ARROW_KEYS,\n    WASD_KEYS,\n    VIM_KEYS,\n    NUMPAD_KEYS,\n    ARROWS_AND_WASD,\n    ARROWS_AND_VIM,\n    KEY_DISPLAY_MAP,\n    KeyMapping,\n    format_key_for_display,\n    format_key_combo\n)\n\n\nFunctions\ndef format_key_for_display(\n    key: str  # the JavaScript key name\n) -&gt; str:     # human-readable display string\n    \"Format a key name for user display.\"\ndef format_key_combo(\n    key: str,                        # the main key\n    modifiers: frozenset[str] = frozenset() # modifier keys (shift, ctrl, alt, meta)\n) -&gt; str:                            # formatted string like \"Ctrl+Shift+A\"\n    \"Format a key combination for display.\"\n\n\nClasses\nclass KeyMapping:\n    \"Maps physical keys to navigation directions.\"\n    \n    def get_direction(\n            self,\n            key: str  # the pressed key (e.g., \"ArrowUp\", \"w\")\n        ) -&gt; str | None: # the direction (\"up\", \"down\", \"left\", \"right\") or None\n        \"Get direction for a given key press.\"\n    \n    def all_keys(self) -&gt; tuple[str, ...]: # all mapped keys\n            \"\"\"Return all mapped keys.\"\"\"\n            return self.up + self.down + self.left + self.right\n    \n        def to_js_map(self) -&gt; dict[str, str]: # {key: direction} mapping\n        \"Return all mapped keys.\"\n    \n    def to_js_map(self) -&gt; dict[str, str]: # {key: direction} mapping\n            \"\"\"Convert to JavaScript-compatible key-to-direction map.\"\"\"\n            result = {}\n            for key in self.up\n        \"Convert to JavaScript-compatible key-to-direction map.\"\n\n\nVariables\nARROW_KEYS\nWASD_KEYS\nVIM_KEYS\nNUMPAD_KEYS\nARROWS_AND_WASD\nARROWS_AND_VIM\nKEY_DISPLAY_MAP: dict[str, str]\n\n\n\nZone Manager (manager.ipynb)\n\nCoordinates keyboard navigation across multiple zones, modes, and actions.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.core.manager import (\n    ZoneManager\n)\n\n\nClasses\n@dataclass\nclass ZoneManager:\n    \"Coordinates keyboard navigation across zones.\"\n    \n    zones: tuple[FocusZone, ...]  # all focus zones\n    prev_zone_key: str = 'ArrowLeft'  # key to switch to previous zone\n    next_zone_key: str = 'ArrowRight'  # key to switch to next zone\n    zone_switch_modifiers: frozenset[str] = field(...)\n    wrap_zones: bool = True  # wrap from last zone to first\n    key_mapping: KeyMapping = field(...)\n    initial_zone_id: Optional[str]  # defaults to first zone\n    modes: tuple[KeyboardMode, ...] = ()  # custom modes (navigation mode is implicit)\n    default_mode: str = 'navigation'  # mode to return to after exiting others\n    actions: tuple[KeyAction, ...] = ()  # keyboard action bindings\n    on_zone_change: Optional[str]  # called when active zone changes\n    on_mode_change: Optional[str]  # called when mode changes\n    on_state_change: Optional[str]  # called on any state change (for persistence)\n    skip_when_input_focused: bool = True  # ignore keys in input/textarea\n    input_selector: str = 'input, textarea, select, [contenteditable]'  # elements to skip\n    htmx_settle_event: str = 'htmx:afterSettle'  # event to reinitialize on\n    expose_state_globally: bool = False  # expose state on window object\n    global_state_name: str = 'keyboardNavState'  # name for global state\n    state_hidden_inputs: bool = False  # write state to hidden inputs\n    \n    def get_zone(\n            self,\n            zone_id: str  # zone ID to find\n        ) -&gt; Optional[FocusZone]: # the zone or None\n        \"Get zone by ID.\"\n    \n    def get_initial_zone_id(self) -&gt; str: # the initial zone ID\n            \"\"\"Get initial zone ID.\"\"\"\n            return self.initial_zone_id or self.zones[0].id\n    \n        def get_all_modes(self) -&gt; tuple[KeyboardMode, ...]: # all modes including default\n        \"Get initial zone ID.\"\n    \n    def get_all_modes(self) -&gt; tuple[KeyboardMode, ...]: # all modes including default\n            \"\"\"Get all modes including the default navigation mode.\"\"\"\n            return (NAVIGATION_MODE,) + self.modes\n    \n        def get_mode(\n            self,\n            mode_name: str  # mode name to find\n        ) -&gt; Optional[KeyboardMode]: # the mode or None\n        \"Get all modes including the default navigation mode.\"\n    \n    def get_mode(\n            self,\n            mode_name: str  # mode name to find\n        ) -&gt; Optional[KeyboardMode]: # the mode or None\n        \"Get mode by name.\"\n    \n    def get_actions_for_context(\n            self,\n            zone_id: str,  # current zone\n            mode_name: str  # current mode\n        ) -&gt; list[KeyAction]: # actions valid in this context\n        \"Get actions valid for given zone and mode.\"\n    \n    def get_all_data_attributes(self) -&gt; set[str]: # unique data attributes across all zones\n            \"\"\"Get all unique data attributes from all zones.\"\"\"\n            attrs = set()\n            for zone in self.zones\n        \"Get all unique data attributes from all zones.\"\n    \n    def to_js_config(self) -&gt; dict: # JavaScript-compatible configuration\n            \"\"\"Convert to JavaScript configuration object.\"\"\"\n            return {\n                \"zones\": [z.to_js_config() for z in self.zones],\n        \"Convert to JavaScript configuration object.\"\n\n\n\nKeyboard Modes (modes.ipynb)\n\nConfiguration for keyboard modes that change navigation and action behavior.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.core.modes import (\n    NAVIGATION_MODE,\n    KeyboardMode\n)\n\n\nClasses\n@dataclass\nclass KeyboardMode:\n    \"A named mode that changes keyboard behavior.\"\n    \n    name: str  # unique mode name (e.g., \"navigation\", \"split\", \"audition\")\n    enter_key: Optional[str]  # key to enter mode (None = programmatic only)\n    enter_modifiers: frozenset[str] = field(...)\n    exit_key: str = 'Escape'  # key to exit mode\n    exit_modifiers: frozenset[str] = field(...)\n    zone_ids: Optional[tuple[str, ...]]  # only available in these zones (None = all)\n    navigation_override: Optional[NavigationPattern]  # override zone's navigation pattern\n    on_enter: Optional[str]  # called when entering mode\n    on_exit: Optional[str]  # called when exiting mode\n    indicator_text: Optional[str]  # text shown in UI when mode is active\n    exit_on_zone_change: bool = True  # exit mode when switching zones\n    \n    def is_available_in_zone(\n            self,\n            zone_id: str  # the zone to check\n        ) -&gt; bool:        # True if mode is available in zone\n        \"Check if mode is available in given zone.\"\n    \n    def to_js_config(self) -&gt; dict: # JavaScript-compatible configuration\n            \"\"\"Convert to JavaScript configuration object.\"\"\"\n            return {\n                \"name\": self.name,\n        \"Convert to JavaScript configuration object.\"\n\n\nVariables\nNAVIGATION_MODE\n\n\n\nNavigation Patterns (navigation.ipynb)\n\nProtocols and implementations for keyboard navigation within focus zones.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import (\n    Direction,\n    NavigationPattern,\n    LinearVertical,\n    LinearHorizontal,\n    ScrollOnly,\n    Grid\n)\n\n\nClasses\n@runtime_checkable\nclass NavigationPattern(Protocol):\n    \"Protocol for navigation within a focus zone.\"\n    \n    def name(self) -&gt; str: # unique identifier for this pattern\n            \"\"\"Return the pattern name.\"\"\"\n            ...\n    \n        def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # navigation direction\n            total: int,        # total number of items\n            columns: int = 1   # number of columns (for grid navigation)\n        ) -&gt; int:              # the new index after navigation\n        \"Return the pattern name.\"\n    \n    def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # navigation direction\n            total: int,        # total number of items\n            columns: int = 1   # number of columns (for grid navigation)\n        ) -&gt; int:              # the new index after navigation\n        \"Calculate next index given current position and direction.\"\n    \n    def get_supported_directions(self) -&gt; tuple[Direction, ...]: # directions this pattern responds to\n        \"Return which arrow key directions this pattern handles.\"\n@dataclass\nclass LinearVertical:\n    \"Up/Down navigation through a vertical list.\"\n    \n    wrap: bool = False  # wrap from last item to first (and vice versa)\n    \n    def name(self) -&gt; str:\n            \"\"\"Return the pattern name.\"\"\"\n            return \"linear_vertical\"\n    \n        def get_supported_directions(self) -&gt; tuple[Direction, ...]: # (\"up\", \"down\")\n        \"Return the pattern name.\"\n    \n    def get_supported_directions(self) -&gt; tuple[Direction, ...]: # (\"up\", \"down\")\n            \"\"\"Return supported directions.\"\"\"\n            return (\"up\", \"down\")\n    \n        def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # \"up\" or \"down\"\n            total: int,        # total number of items\n            columns: int = 1   # unused for linear navigation\n        ) -&gt; int:              # the new index\n        \"Return supported directions.\"\n    \n    def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # \"up\" or \"down\"\n            total: int,        # total number of items\n            columns: int = 1   # unused for linear navigation\n        ) -&gt; int:              # the new index\n        \"Calculate next index for vertical navigation.\"\n@dataclass\nclass LinearHorizontal:\n    \"Left/Right navigation through a horizontal list.\"\n    \n    wrap: bool = False  # wrap from last item to first (and vice versa)\n    \n    def name(self) -&gt; str:\n            \"\"\"Return the pattern name.\"\"\"\n            return \"linear_horizontal\"\n    \n        def get_supported_directions(self) -&gt; tuple[Direction, ...]: # (\"left\", \"right\")\n        \"Return the pattern name.\"\n    \n    def get_supported_directions(self) -&gt; tuple[Direction, ...]: # (\"left\", \"right\")\n            \"\"\"Return supported directions.\"\"\"\n            return (\"left\", \"right\")\n    \n        def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # \"left\" or \"right\"\n            total: int,        # total number of items\n            columns: int = 1   # unused for linear navigation\n        ) -&gt; int:              # the new index\n        \"Return supported directions.\"\n    \n    def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # \"left\" or \"right\"\n            total: int,        # total number of items\n            columns: int = 1   # unused for linear navigation\n        ) -&gt; int:              # the new index\n        \"Calculate next index for horizontal navigation.\"\n@dataclass\nclass ScrollOnly:\n    \"No item navigation, zone is scrollable content only.\"\n    \n    def name(self) -&gt; str:\n            \"\"\"Return the pattern name.\"\"\"\n            return \"scroll_only\"\n    \n        def get_supported_directions(self) -&gt; tuple[Direction, ...]: # empty tuple\n        \"Return the pattern name.\"\n    \n    def get_supported_directions(self) -&gt; tuple[Direction, ...]: # empty tuple\n            \"\"\"Return no supported directions.\"\"\"\n            return ()\n    \n        def get_next_index(\n            self,\n            current: int,      # current index (unused)\n            direction: Direction, # direction (unused)\n            total: int,        # total items (unused)\n            columns: int = 1   # columns (unused)\n        ) -&gt; int:              # always returns current\n        \"Return no supported directions.\"\n    \n    def get_next_index(\n            self,\n            current: int,      # current index (unused)\n            direction: Direction, # direction (unused)\n            total: int,        # total items (unused)\n            columns: int = 1   # columns (unused)\n        ) -&gt; int:              # always returns current\n        \"Return current index unchanged.\"\n@dataclass\nclass Grid:\n    \"2D grid navigation (placeholder for future implementation).\"\n    \n    columns: int = 4  # number of columns in the grid\n    wrap_horizontal: bool = True  # wrap at row edges\n    wrap_vertical: bool = False  # wrap at grid top/bottom\n    \n    def name(self) -&gt; str:\n            \"\"\"Return the pattern name.\"\"\"\n            return \"grid\"\n    \n        def get_supported_directions(self) -&gt; tuple[Direction, ...]: # all four directions\n        \"Return the pattern name.\"\n    \n    def get_supported_directions(self) -&gt; tuple[Direction, ...]: # all four directions\n            \"\"\"Return all four directions.\"\"\"\n            return (\"up\", \"down\", \"left\", \"right\")\n    \n        def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # navigation direction\n            total: int,        # total number of items\n            columns: int = 0   # override columns (0 = use self.columns)\n        ) -&gt; int:              # the new index\n        \"Return all four directions.\"\n    \n    def get_next_index(\n            self,\n            current: int,      # current focused index\n            direction: Direction, # navigation direction\n            total: int,        # total number of items\n            columns: int = 0   # override columns (0 = use self.columns)\n        ) -&gt; int:              # the new index\n        \"Calculate next index for 2D grid navigation.\"\n\n\n\nKeyboard System (system.ipynb)\n\nHigh-level API for rendering complete keyboard navigation systems.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.components.system import (\n    KeyboardSystem,\n    render_keyboard_system,\n    quick_keyboard_system\n)\n\n\nFunctions\ndef _build_auto_include_map(\n    manager: ZoneManager,        # the zone manager configuration\n    include_state: bool = False  # include state inputs in selector\n) -&gt; dict[str, str]:             # action button ID -&gt; include selector\n    \"Auto-generate include_map based on actions and their zone constraints.\"\ndef render_keyboard_system(\n    manager: ZoneManager,                         # the zone manager configuration\n    url_map: dict[str, str],                      # action button ID -&gt; URL\n    target_map: dict[str, str],                   # action button ID -&gt; target selector\n    include_map: dict[str, str] | None = None,    # action button ID -&gt; include selector (auto-generated if None)\n    swap_map: dict[str, str] | None = None,       # action button ID -&gt; swap value\n    vals_map: dict[str, dict] | None = None,      # action button ID -&gt; hx-vals dict\n    show_hints: bool = True,                      # render keyboard hints UI\n    hints_badge_style: str = \"ghost\",             # badge style for hints\n    include_state_inputs: bool = False            # include state tracking inputs\n) -&gt; KeyboardSystem:                              # complete keyboard system\n    \"Render complete keyboard navigation system.\"\ndef quick_keyboard_system(\n    zones: tuple[FocusZone, ...],                # focus zones\n    actions: tuple[KeyAction, ...],              # keyboard actions\n    url_map: dict[str, str],                     # action URLs\n    target_map: dict[str, str],                  # action targets\n    **kwargs                                     # additional ZoneManager/render options\n) -&gt; KeyboardSystem:                             # complete keyboard system\n    \"Quick setup for simple keyboard navigation.\"\n\n\nClasses\n@dataclass\nclass KeyboardSystem:\n    \"Container for all keyboard navigation components.\"\n    \n    script: Script  # the keyboard navigation JavaScript\n    hidden_inputs: Div  # hidden inputs for HTMX\n    action_buttons: Div  # hidden action buttons for HTMX\n    hints: Optional[Div]  # optional keyboard hints UI\n    \n    def all_components(self) -&gt; tuple:  # all components as tuple\n            \"\"\"Return all components for easy unpacking into render.\"\"\"\n            components = [self.script, self.hidden_inputs, self.action_buttons]\n            if self.hints\n        \"Return all components for easy unpacking into render.\"\n\n\n\nJavaScript Utilities (utils.ipynb)\n\nCore JavaScript utility generators for keyboard navigation.\n\n\nImport\nfrom cjm_fasthtml_keyboard_navigation.js.utils import (\n    js_config_from_dict,\n    js_input_detection,\n    js_focus_ring_helpers,\n    js_scroll_into_view,\n    js_hidden_input_update,\n    js_trigger_click,\n    js_get_data_attributes,\n    js_get_modifiers,\n    js_all_utils\n)\n\n\nFunctions\ndef js_config_from_dict(\n    config: dict[str, Any],  # Python dict to convert\n    var_name: str = \"cfg\"    # JavaScript variable name\n) -&gt; str:                    # JavaScript const declaration\n    \"Generate JavaScript const declaration from Python dict.\"\ndef js_input_detection(\n    selector: str = \"input, textarea, select, [contenteditable='true']\"  # CSS selector for input elements\n) -&gt; str:  # JavaScript function definition\n    \"Generate JavaScript function to detect if input element is focused.\"\ndef js_focus_ring_helpers(\n    default_classes: tuple[str, ...] = (str(ring(2)), str(ring_dui.primary))  # default focus ring CSS classes\n) -&gt; str:  # JavaScript function definitions\n    \"Generate JavaScript functions for adding/removing focus ring classes.\"\ndef js_scroll_into_view(\n    behavior: str = \"smooth\",  # \"smooth\" or \"auto\"\n    block: str = \"nearest\"     # \"start\", \"center\", \"end\", \"nearest\"\n) -&gt; str:  # JavaScript function definition\n    \"Generate JavaScript function to scroll element into view.\"\ndef js_hidden_input_update() -&gt; str: # JavaScript function definition\n    \"Generate JavaScript function to update hidden input values.\"\ndef js_trigger_click() -&gt; str: # JavaScript function definition\n    \"Generate JavaScript function to programmatically click a button.\"\ndef js_get_data_attributes() -&gt; str: # JavaScript function definition\n    \"Generate JavaScript function to extract data attributes from element.\"\ndef js_get_modifiers() -&gt; str: # JavaScript function definition\n    \"Generate JavaScript function to extract modifier keys from event.\"\ndef js_all_utils(\n    input_selector: str = \"input, textarea, select, [contenteditable='true']\",  # input element selector\n    default_focus_classes: tuple[str, ...] = (str(ring(2)), str(ring_dui.primary)),  # focus ring classes\n    scroll_behavior: str = \"smooth\",  # scroll behavior\n    scroll_block: str = \"nearest\"     # scroll block alignment\n) -&gt; str:  # all utility functions combined\n    \"Generate all JavaScript utility functions.\"",
    "crumbs": [
      "cjm-fasthtml-keyboard-navigation"
    ]
  },
  {
    "objectID": "components/system.html",
    "href": "components/system.html",
    "title": "Keyboard System",
    "section": "",
    "text": "source\n\n\n\ndef KeyboardSystem(\n    script:Script, hidden_inputs:Div, action_buttons:Div, hints:Optional[Div]=None\n)-&gt;None:\n\nContainer for all keyboard navigation components.",
    "crumbs": [
      "components",
      "Keyboard System"
    ]
  },
  {
    "objectID": "components/system.html#keyboardsystem-result",
    "href": "components/system.html#keyboardsystem-result",
    "title": "Keyboard System",
    "section": "",
    "text": "source\n\n\n\ndef KeyboardSystem(\n    script:Script, hidden_inputs:Div, action_buttons:Div, hints:Optional[Div]=None\n)-&gt;None:\n\nContainer for all keyboard navigation components.",
    "crumbs": [
      "components",
      "Keyboard System"
    ]
  },
  {
    "objectID": "components/system.html#render-keyboard-system",
    "href": "components/system.html#render-keyboard-system",
    "title": "Keyboard System",
    "section": "Render Keyboard System",
    "text": "Render Keyboard System\nThe main entry point for generating keyboard navigation components.\nIf include_map is not provided, it will be auto-generated based on the actions: - Actions with zone_ids will include only those zones’ hidden inputs - Actions without zone_ids will include all zones’ hidden inputs\nThis ensures HTMX requests automatically include the focused item’s data attributes.\n\nsource\n\nrender_keyboard_system\n\ndef render_keyboard_system(\n    manager:ZoneManager, # the zone manager configuration\n    url_map:dict[str, str], # action button ID -&gt; URL\n    target_map:dict[str, str], # action button ID -&gt; target selector\n    include_map:dict[str, str] | None=None, # action button ID -&gt; include selector (auto-generated if None)\n    swap_map:dict[str, str] | None=None, # action button ID -&gt; swap value\n    vals_map:dict[str, dict] | None=None, # action button ID -&gt; hx-vals dict\n    show_hints:bool=True, # render keyboard hints UI\n    hints_badge_style:str='ghost', # badge style for hints\n    include_state_inputs:bool=False, # include state tracking inputs\n)-&gt;KeyboardSystem: # complete keyboard system\n\nRender complete keyboard navigation system.\n\n# Test render_keyboard_system\nfrom fasthtml.common import to_xml\nfrom cjm_fasthtml_keyboard_navigation.core.focus_zone import FocusZone\nfrom cjm_fasthtml_keyboard_navigation.core.actions import KeyAction\n\nbrowser = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr.item\",\n    data_attributes=(\"job-id\",)\n)\nqueue = FocusZone(\n    id=\"queue\",\n    item_selector=\"li.item\"\n)\n\nmanager = ZoneManager(\n    zones=(browser, queue),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"toggle-btn\", description=\"Select\"),\n        KeyAction(key=\"Delete\", htmx_trigger=\"delete-btn\", description=\"Remove\"),\n    )\n)\n\nsystem = render_keyboard_system(\n    manager,\n    url_map={\n        \"toggle-btn\": \"/toggle\",\n        \"delete-btn\": \"/delete\"\n    },\n    target_map={\n        \"toggle-btn\": \"#list\",\n        \"delete-btn\": \"#list\"\n    }\n)\n\nassert isinstance(system, KeyboardSystem)\nassert system.hints is not None\n\n# Check script\nscript_html = to_xml(system.script)\nassert \"handleKeydown\" in script_html\n\n# Check hidden inputs\ninputs_html = to_xml(system.hidden_inputs)\nassert 'id=\"browser-job-id\"' in inputs_html\n\n# Check action buttons - no hx-trigger by default (JS handles triggering)\nbuttons_html = to_xml(system.action_buttons)\nassert 'id=\"toggle-btn\"' in buttons_html\nassert 'id=\"delete-btn\"' in buttons_html\nassert 'hx-trigger' not in buttons_html  # JavaScript handles triggering\n\n# Check hints\nhints_html = to_xml(system.hints)\nassert \"Select\" in hints_html\n\n\n# Test without hints\nsystem_no_hints = render_keyboard_system(\n    manager,\n    url_map={\"toggle-btn\": \"/toggle\", \"delete-btn\": \"/delete\"},\n    target_map={\"toggle-btn\": \"#list\", \"delete-btn\": \"#list\"},\n    show_hints=False\n)\n\nassert system_no_hints.hints is None\nassert len(system_no_hints.all_components()) == 3  # No hints\n\n\n# Test with vals_map for direction parameters\nmanager_with_reorder = ZoneManager(\n    zones=(browser, queue),\n    actions=(\n        KeyAction(key=\"ArrowUp\", modifiers=frozenset({\"shift\"}), htmx_trigger=\"reorder-up-btn\"),\n        KeyAction(key=\"ArrowDown\", modifiers=frozenset({\"shift\"}), htmx_trigger=\"reorder-down-btn\"),\n    )\n)\n\nsystem_with_vals = render_keyboard_system(\n    manager_with_reorder,\n    url_map={\n        \"reorder-up-btn\": \"/reorder\",\n        \"reorder-down-btn\": \"/reorder\"\n    },\n    target_map={\n        \"reorder-up-btn\": \"#queue\",\n        \"reorder-down-btn\": \"#queue\"\n    },\n    vals_map={\n        \"reorder-up-btn\": {\"direction\": \"up\"},\n        \"reorder-down-btn\": {\"direction\": \"down\"}\n    },\n    show_hints=False\n)\n\nbuttons_html = to_xml(system_with_vals.action_buttons)\nassert '\"direction\": \"up\"' in buttons_html\nassert '\"direction\": \"down\"' in buttons_html\n\n\n# Test all_components unpacking\ncomponents = system.all_components()\nassert len(components) == 4  # script, inputs, buttons, hints",
    "crumbs": [
      "components",
      "Keyboard System"
    ]
  },
  {
    "objectID": "components/system.html#quick-setup-function",
    "href": "components/system.html#quick-setup-function",
    "title": "Keyboard System",
    "section": "Quick Setup Function",
    "text": "Quick Setup Function\nFor simpler use cases with sensible defaults.\n\nsource\n\nquick_keyboard_system\n\ndef quick_keyboard_system(\n    zones:tuple[FocusZone, ...], # focus zones\n    actions:tuple[KeyAction, ...], # keyboard actions\n    url_map:dict[str, str], # action URLs\n    target_map:dict[str, str], # action targets\n    kwargs:VAR_KEYWORD\n)-&gt;KeyboardSystem: # complete keyboard system\n\nQuick setup for simple keyboard navigation.\n\n# Test quick setup\nsystem = quick_keyboard_system(\n    zones=(browser,),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"select-btn\", description=\"Select\"),\n    ),\n    url_map={\"select-btn\": \"/select\"},\n    target_map={\"select-btn\": \"#list\"},\n    show_hints=False\n)\n\nassert isinstance(system, KeyboardSystem)\nassert system.hints is None",
    "crumbs": [
      "components",
      "Keyboard System"
    ]
  },
  {
    "objectID": "components/hints.html",
    "href": "components/hints.html",
    "title": "Keyboard Hints",
    "section": "",
    "text": "source\n\n\n\ndef create_modifier_key_hint(\n    modifier:str, # modifier key name (e.g., \"shift\", \"ctrl\")\n    key_icon_or_text:Union[str, FT], # the main key icon or text\n    description:str, # action description\n    style:str='ghost', # badge style\n)-&gt;Div: # hint badge with modifier + key\n\nCreate a hint badge with a modifier key and main key.\n\nsource\n\n\n\n\ndef create_nav_icon_hint(\n    icon_name:str, # lucide icon name (e.g., \"arrow-down-up\")\n    description:str, # action description\n    style:str='ghost', # badge style\n)-&gt;Div: # hint badge with icon\n\nCreate a hint badge with a lucide icon.\n\nsource\n\n\n\n\ndef render_hint_badge(\n    key_display:Union[str, FT], # formatted key string or icon component\n    description:str, # action description\n    style:str='ghost', # badge style (ghost, outline, soft, dash)\n    auto_icon:bool=False, # auto-convert known keys to icons\n)-&gt;Div: # hint badge component\n\nRender a single keyboard hint as a badge.\n\nsource\n\n\n\n\ndef get_key_icon(\n    key_name:str, # key name to look up (case-insensitive)\n    size:int=3, # icon size\n)-&gt;FT | None: # icon component or None if no icon mapping\n\nGet a lucide icon for a key name, if one exists.\n\n# Test hint badge with string\nfrom fasthtml.common import to_xml\n\nhint_badge = render_hint_badge(\"Space\", \"Select\")\nhtml = to_xml(hint_badge)\nassert \"Space\" in html\nassert \"Select\" in html\nassert \"badge\" in html\n\n# Test hint badge with icon\nicon_hint = create_nav_icon_hint(\"arrow-down-up\", \"Navigate\")\nhtml = to_xml(icon_hint)\nassert \"Navigate\" in html\nassert \"svg\" in html  # Icon is an SVG\n\n# Test auto_icon conversion\ndelete_hint = render_hint_badge(\"Delete\", \"Remove item\", auto_icon=True)\nhtml = to_xml(delete_hint)\nassert \"svg\" in html  # Should convert to trash icon\nassert \"Remove item\" in html\n\n# Test get_key_icon\nassert get_key_icon(\"shift\") is not None\nassert get_key_icon(\"delete\") is not None\nassert get_key_icon(\"unknown_key\") is None\n\n# Test modifier key hint (Shift + arrow)\nshift_nav = create_modifier_key_hint(\"shift\", lucide_icon(\"arrow-down-up\", size=3), \"Reorder\")\nhtml = to_xml(shift_nav)\nassert \"svg\" in html\nassert \"Reorder\" in html",
    "crumbs": [
      "components",
      "Keyboard Hints"
    ]
  },
  {
    "objectID": "components/hints.html#single-hint-badge",
    "href": "components/hints.html#single-hint-badge",
    "title": "Keyboard Hints",
    "section": "",
    "text": "source\n\n\n\ndef create_modifier_key_hint(\n    modifier:str, # modifier key name (e.g., \"shift\", \"ctrl\")\n    key_icon_or_text:Union[str, FT], # the main key icon or text\n    description:str, # action description\n    style:str='ghost', # badge style\n)-&gt;Div: # hint badge with modifier + key\n\nCreate a hint badge with a modifier key and main key.\n\nsource\n\n\n\n\ndef create_nav_icon_hint(\n    icon_name:str, # lucide icon name (e.g., \"arrow-down-up\")\n    description:str, # action description\n    style:str='ghost', # badge style\n)-&gt;Div: # hint badge with icon\n\nCreate a hint badge with a lucide icon.\n\nsource\n\n\n\n\ndef render_hint_badge(\n    key_display:Union[str, FT], # formatted key string or icon component\n    description:str, # action description\n    style:str='ghost', # badge style (ghost, outline, soft, dash)\n    auto_icon:bool=False, # auto-convert known keys to icons\n)-&gt;Div: # hint badge component\n\nRender a single keyboard hint as a badge.\n\nsource\n\n\n\n\ndef get_key_icon(\n    key_name:str, # key name to look up (case-insensitive)\n    size:int=3, # icon size\n)-&gt;FT | None: # icon component or None if no icon mapping\n\nGet a lucide icon for a key name, if one exists.\n\n# Test hint badge with string\nfrom fasthtml.common import to_xml\n\nhint_badge = render_hint_badge(\"Space\", \"Select\")\nhtml = to_xml(hint_badge)\nassert \"Space\" in html\nassert \"Select\" in html\nassert \"badge\" in html\n\n# Test hint badge with icon\nicon_hint = create_nav_icon_hint(\"arrow-down-up\", \"Navigate\")\nhtml = to_xml(icon_hint)\nassert \"Navigate\" in html\nassert \"svg\" in html  # Icon is an SVG\n\n# Test auto_icon conversion\ndelete_hint = render_hint_badge(\"Delete\", \"Remove item\", auto_icon=True)\nhtml = to_xml(delete_hint)\nassert \"svg\" in html  # Should convert to trash icon\nassert \"Remove item\" in html\n\n# Test get_key_icon\nassert get_key_icon(\"shift\") is not None\nassert get_key_icon(\"delete\") is not None\nassert get_key_icon(\"unknown_key\") is None\n\n# Test modifier key hint (Shift + arrow)\nshift_nav = create_modifier_key_hint(\"shift\", lucide_icon(\"arrow-down-up\", size=3), \"Reorder\")\nhtml = to_xml(shift_nav)\nassert \"svg\" in html\nassert \"Reorder\" in html",
    "crumbs": [
      "components",
      "Keyboard Hints"
    ]
  },
  {
    "objectID": "components/hints.html#hint-group",
    "href": "components/hints.html#hint-group",
    "title": "Keyboard Hints",
    "section": "Hint Group",
    "text": "Hint Group\n\nsource\n\nrender_hint_group\n\ndef render_hint_group(\n    group_name:str, # group header text\n    hints:list[tuple[str, str]], # list of (key_display, description) tuples\n    badge_style:str='ghost', # badge style for this group\n)-&gt;Div: # group container with header and hints\n\nRender a group of related keyboard hints.\n\n# Test hint group with string keys\ngroup = render_hint_group(\n    \"Navigation\",\n    [(\"W/S\", \"Move\"), (\"A/D\", \"Switch\")]\n)\nhtml = to_xml(group)\nassert \"Navigation\" in html\nassert \"Move\" in html\nassert \"Switch\" in html",
    "crumbs": [
      "components",
      "Keyboard Hints"
    ]
  },
  {
    "objectID": "components/hints.html#hints-from-actions",
    "href": "components/hints.html#hints-from-actions",
    "title": "Keyboard Hints",
    "section": "Hints from Actions",
    "text": "Hints from Actions\n\nsource\n\ngroup_actions_by_hint_group\n\ndef group_actions_by_hint_group(\n    actions:tuple[KeyAction, ...], # actions to group\n)-&gt;dict[str, list[KeyAction]]: # grouped actions\n\nGroup actions by their hint_group attribute.\n\nsource\n\n\nrender_hints_from_actions\n\ndef render_hints_from_actions(\n    actions:tuple[KeyAction, ...], # actions to display hints for\n    badge_style:str='ghost', # badge style\n)-&gt;Div: # container with all hint groups\n\nRender keyboard hints from action configurations.\n\n# Test hints from actions\nactions = (\n    KeyAction(key=\" \", htmx_trigger=\"x\", description=\"Select\", hint_group=\"Selection\"),\n    KeyAction(key=\"Delete\", htmx_trigger=\"y\", description=\"Remove\", hint_group=\"Actions\"),\n    KeyAction(key=\"Enter\", js_callback=\"z\", description=\"Open\", hint_group=\"Actions\"),\n    KeyAction(key=\"Backspace\", htmx_trigger=\"w\", description=\"Delete\", show_in_hints=False),  # Hidden\n)\n\nhints_component = render_hints_from_actions(actions)\nhtml = to_xml(hints_component)\nassert \"Selection\" in html\nassert \"Actions\" in html\nassert \"Select\" in html\nassert \"Remove\" in html\nassert \"Delete\" not in html  # show_in_hints=False",
    "crumbs": [
      "components",
      "Keyboard Hints"
    ]
  },
  {
    "objectID": "components/hints.html#full-keyboard-hints",
    "href": "components/hints.html#full-keyboard-hints",
    "title": "Keyboard Hints",
    "section": "Full Keyboard Hints",
    "text": "Full Keyboard Hints\n\nsource\n\nrender_keyboard_hints\n\ndef render_keyboard_hints(\n    manager:ZoneManager, # the zone manager\n    include_navigation:bool=True, # include navigation hints\n    include_zone_switch:bool=True, # include zone switching hints\n    badge_style:str='ghost', # badge style\n    container_id:str='kb-hints', # container element ID\n    use_icons:bool=True, # use lucide icons for nav hints\n)-&gt;Div: # complete hints component\n\nRender complete keyboard hints for a zone manager.\n\n# Test full keyboard hints with icons (default)\nfrom cjm_fasthtml_keyboard_navigation.core.focus_zone import FocusZone\n\nzone1 = FocusZone(id=\"z1\")\nzone2 = FocusZone(id=\"z2\")\n\nmanager = ZoneManager(\n    zones=(zone1, zone2),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"toggle\", description=\"Select\", hint_group=\"Selection\"),\n    )\n)\n\nhints = render_keyboard_hints(manager)\nhtml = to_xml(hints)\n\nassert 'id=\"kb-hints\"' in html\nassert \"Navigate\" in html\nassert \"Switch Panel\" in html  # Two zones = show zone switch\nassert \"Select\" in html\nassert \"svg\" in html  # Icons are SVGs\n\n# Test without icons\nhints_no_icons = render_keyboard_hints(manager, use_icons=False)\nhtml_no_icons = to_xml(hints_no_icons)\nassert \"↑/↓\" in html_no_icons  # Text arrows when icons disabled\n\n\n# Single zone = no zone switch hint\nsingle_manager = ZoneManager(zones=(zone1,), actions=())\nhints = render_keyboard_hints(single_manager)\nhtml = to_xml(hints)\nassert \"Switch Panel\" not in html",
    "crumbs": [
      "components",
      "Keyboard Hints"
    ]
  },
  {
    "objectID": "core/manager.html",
    "href": "core/manager.html",
    "title": "Zone Manager",
    "section": "",
    "text": "The main coordinator that brings together zones, modes, actions, and key mappings.\n\nsource\n\n\n\ndef ZoneManager(\n    zones:tuple[FocusZone, ...], prev_zone_key:str='ArrowLeft', next_zone_key:str='ArrowRight',\n    zone_switch_modifiers:frozenset[str]=&lt;factory&gt;, wrap_zones:bool=True, key_mapping:KeyMapping=&lt;factory&gt;,\n    initial_zone_id:Optional[str]=None, modes:tuple[KeyboardMode, ...]=(), default_mode:str='navigation',\n    actions:tuple[KeyAction, ...]=(), on_zone_change:Optional[str]=None, on_mode_change:Optional[str]=None,\n    on_state_change:Optional[str]=None, skip_when_input_focused:bool=True,\n    input_selector:str='input, textarea, select, [contenteditable]', htmx_settle_event:str='htmx:afterSettle',\n    expose_state_globally:bool=False, global_state_name:str='keyboardNavState', state_hidden_inputs:bool=False\n)-&gt;None:\n\nCoordinates keyboard navigation across zones.\n\n# Test basic ZoneManager\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import LinearVertical\n\nbrowser = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr.item\",\n    data_attributes=(\"job-id\",)\n)\nqueue = FocusZone(\n    id=\"queue\",\n    item_selector=\"li.item\"\n)\n\nmanager = ZoneManager(\n    zones=(browser, queue),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"toggle\"),\n    )\n)\n\nassert manager.get_zone(\"browser\") == browser\nassert manager.get_zone(\"queue\") == queue\nassert manager.get_zone(\"invalid\") is None\nassert manager.get_initial_zone_id() == \"browser\"\n\n\n# Test modes\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import LinearHorizontal\n\nsplit_mode = KeyboardMode(\n    name=\"split\",\n    enter_key=\"Enter\",\n    navigation_override=LinearHorizontal()\n)\n\nmanager_with_modes = ZoneManager(\n    zones=(browser,),\n    modes=(split_mode,)\n)\n\nall_modes = manager_with_modes.get_all_modes()\nassert len(all_modes) == 2  # navigation + split\nassert manager_with_modes.get_mode(\"navigation\") is not None\nassert manager_with_modes.get_mode(\"split\") == split_mode\n\n\n# Test action filtering\nactions = (\n    KeyAction(key=\" \", htmx_trigger=\"toggle\"),  # all zones/modes\n    KeyAction(key=\"Delete\", htmx_trigger=\"delete\", zone_ids=(\"queue\",)),\n    KeyAction(key=\"Enter\", htmx_trigger=\"split\", mode_names=(\"split\",)),\n)\n\nmanager = ZoneManager(zones=(browser, queue), actions=actions)\n\n# Browser in navigation mode\nbrowser_nav_actions = manager.get_actions_for_context(\"browser\", \"navigation\")\nassert len(browser_nav_actions) == 1  # only space toggle\n\n# Queue in navigation mode\nqueue_nav_actions = manager.get_actions_for_context(\"queue\", \"navigation\")\nassert len(queue_nav_actions) == 2  # space + delete\n\n# Any zone in split mode\nsplit_actions = manager.get_actions_for_context(\"browser\", \"split\")\nassert len(split_actions) == 2  # space + enter\n\n\n# Test validation\nimport traceback\n\n# Empty zones should fail\ntry:\n    ZoneManager(zones=())\n    assert False, \"Should have raised ValueError\"\nexcept ValueError as e:\n    assert \"At least one zone\" in str(e)\n\n# Duplicate zone IDs should fail\ntry:\n    ZoneManager(zones=(\n        FocusZone(id=\"same\"),\n        FocusZone(id=\"same\")\n    ))\n    assert False, \"Should have raised ValueError\"\nexcept ValueError as e:\n    assert \"Duplicate\" in str(e)\n\n# Invalid initial zone should fail\ntry:\n    ZoneManager(\n        zones=(FocusZone(id=\"zone1\"),),\n        initial_zone_id=\"nonexistent\"\n    )\n    assert False, \"Should have raised ValueError\"\nexcept ValueError as e:\n    assert \"not found\" in str(e)\n\n\n# Test JS config generation\nconfig = manager.to_js_config()\n\nassert len(config[\"zones\"]) == 2\nassert config[\"initialZoneId\"] == \"browser\"\nassert config[\"defaultMode\"] == \"navigation\"\nassert config[\"settings\"][\"skipWhenInputFocused\"] == True\n\n\n# Test custom key mapping\nfrom cjm_fasthtml_keyboard_navigation.core.key_mapping import WASD_KEYS\n\nwasd_manager = ZoneManager(\n    zones=(browser,),\n    key_mapping=WASD_KEYS\n)\n\nconfig = wasd_manager.to_js_config()\nassert config[\"keyMapping\"][\"w\"] == \"up\"\nassert config[\"keyMapping\"][\"s\"] == \"down\"\n\n\n# Test data attributes collection\nz1 = FocusZone(id=\"z1\", data_attributes=(\"a\", \"b\"))\nz2 = FocusZone(id=\"z2\", data_attributes=(\"b\", \"c\"))\n\nm = ZoneManager(zones=(z1, z2))\nattrs = m.get_all_data_attributes()\nassert attrs == {\"a\", \"b\", \"c\"}",
    "crumbs": [
      "core",
      "Zone Manager"
    ]
  },
  {
    "objectID": "core/manager.html#zonemanager",
    "href": "core/manager.html#zonemanager",
    "title": "Zone Manager",
    "section": "",
    "text": "The main coordinator that brings together zones, modes, actions, and key mappings.\n\nsource\n\n\n\ndef ZoneManager(\n    zones:tuple[FocusZone, ...], prev_zone_key:str='ArrowLeft', next_zone_key:str='ArrowRight',\n    zone_switch_modifiers:frozenset[str]=&lt;factory&gt;, wrap_zones:bool=True, key_mapping:KeyMapping=&lt;factory&gt;,\n    initial_zone_id:Optional[str]=None, modes:tuple[KeyboardMode, ...]=(), default_mode:str='navigation',\n    actions:tuple[KeyAction, ...]=(), on_zone_change:Optional[str]=None, on_mode_change:Optional[str]=None,\n    on_state_change:Optional[str]=None, skip_when_input_focused:bool=True,\n    input_selector:str='input, textarea, select, [contenteditable]', htmx_settle_event:str='htmx:afterSettle',\n    expose_state_globally:bool=False, global_state_name:str='keyboardNavState', state_hidden_inputs:bool=False\n)-&gt;None:\n\nCoordinates keyboard navigation across zones.\n\n# Test basic ZoneManager\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import LinearVertical\n\nbrowser = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr.item\",\n    data_attributes=(\"job-id\",)\n)\nqueue = FocusZone(\n    id=\"queue\",\n    item_selector=\"li.item\"\n)\n\nmanager = ZoneManager(\n    zones=(browser, queue),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"toggle\"),\n    )\n)\n\nassert manager.get_zone(\"browser\") == browser\nassert manager.get_zone(\"queue\") == queue\nassert manager.get_zone(\"invalid\") is None\nassert manager.get_initial_zone_id() == \"browser\"\n\n\n# Test modes\nfrom cjm_fasthtml_keyboard_navigation.core.navigation import LinearHorizontal\n\nsplit_mode = KeyboardMode(\n    name=\"split\",\n    enter_key=\"Enter\",\n    navigation_override=LinearHorizontal()\n)\n\nmanager_with_modes = ZoneManager(\n    zones=(browser,),\n    modes=(split_mode,)\n)\n\nall_modes = manager_with_modes.get_all_modes()\nassert len(all_modes) == 2  # navigation + split\nassert manager_with_modes.get_mode(\"navigation\") is not None\nassert manager_with_modes.get_mode(\"split\") == split_mode\n\n\n# Test action filtering\nactions = (\n    KeyAction(key=\" \", htmx_trigger=\"toggle\"),  # all zones/modes\n    KeyAction(key=\"Delete\", htmx_trigger=\"delete\", zone_ids=(\"queue\",)),\n    KeyAction(key=\"Enter\", htmx_trigger=\"split\", mode_names=(\"split\",)),\n)\n\nmanager = ZoneManager(zones=(browser, queue), actions=actions)\n\n# Browser in navigation mode\nbrowser_nav_actions = manager.get_actions_for_context(\"browser\", \"navigation\")\nassert len(browser_nav_actions) == 1  # only space toggle\n\n# Queue in navigation mode\nqueue_nav_actions = manager.get_actions_for_context(\"queue\", \"navigation\")\nassert len(queue_nav_actions) == 2  # space + delete\n\n# Any zone in split mode\nsplit_actions = manager.get_actions_for_context(\"browser\", \"split\")\nassert len(split_actions) == 2  # space + enter\n\n\n# Test validation\nimport traceback\n\n# Empty zones should fail\ntry:\n    ZoneManager(zones=())\n    assert False, \"Should have raised ValueError\"\nexcept ValueError as e:\n    assert \"At least one zone\" in str(e)\n\n# Duplicate zone IDs should fail\ntry:\n    ZoneManager(zones=(\n        FocusZone(id=\"same\"),\n        FocusZone(id=\"same\")\n    ))\n    assert False, \"Should have raised ValueError\"\nexcept ValueError as e:\n    assert \"Duplicate\" in str(e)\n\n# Invalid initial zone should fail\ntry:\n    ZoneManager(\n        zones=(FocusZone(id=\"zone1\"),),\n        initial_zone_id=\"nonexistent\"\n    )\n    assert False, \"Should have raised ValueError\"\nexcept ValueError as e:\n    assert \"not found\" in str(e)\n\n\n# Test JS config generation\nconfig = manager.to_js_config()\n\nassert len(config[\"zones\"]) == 2\nassert config[\"initialZoneId\"] == \"browser\"\nassert config[\"defaultMode\"] == \"navigation\"\nassert config[\"settings\"][\"skipWhenInputFocused\"] == True\n\n\n# Test custom key mapping\nfrom cjm_fasthtml_keyboard_navigation.core.key_mapping import WASD_KEYS\n\nwasd_manager = ZoneManager(\n    zones=(browser,),\n    key_mapping=WASD_KEYS\n)\n\nconfig = wasd_manager.to_js_config()\nassert config[\"keyMapping\"][\"w\"] == \"up\"\nassert config[\"keyMapping\"][\"s\"] == \"down\"\n\n\n# Test data attributes collection\nz1 = FocusZone(id=\"z1\", data_attributes=(\"a\", \"b\"))\nz2 = FocusZone(id=\"z2\", data_attributes=(\"b\", \"c\"))\n\nm = ZoneManager(zones=(z1, z2))\nattrs = m.get_all_data_attributes()\nassert attrs == {\"a\", \"b\", \"c\"}",
    "crumbs": [
      "core",
      "Zone Manager"
    ]
  },
  {
    "objectID": "core/navigation.html",
    "href": "core/navigation.html",
    "title": "Navigation Patterns",
    "section": "",
    "text": "Navigation directions supported by the framework.",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#direction-type",
    "href": "core/navigation.html#direction-type",
    "title": "Navigation Patterns",
    "section": "",
    "text": "Navigation directions supported by the framework.",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#navigationpattern-protocol",
    "href": "core/navigation.html#navigationpattern-protocol",
    "title": "Navigation Patterns",
    "section": "NavigationPattern Protocol",
    "text": "NavigationPattern Protocol\nThe base protocol that all navigation patterns must implement.\n\nsource\n\nNavigationPattern\n\ndef NavigationPattern(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nProtocol for navigation within a focus zone.",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#linearvertical",
    "href": "core/navigation.html#linearvertical",
    "title": "Navigation Patterns",
    "section": "LinearVertical",
    "text": "LinearVertical\nUp/Down navigation through a vertical list of items. This is the most common pattern.\n\nsource\n\nLinearVertical\n\ndef LinearVertical(\n    wrap:bool=False\n)-&gt;None:\n\nUp/Down navigation through a vertical list.\n\n# Test LinearVertical\nnav = LinearVertical()\nassert nav.name == \"linear_vertical\"\nassert nav.get_supported_directions() == (\"up\", \"down\")\nassert nav.get_next_index(0, \"down\", 5) == 1\nassert nav.get_next_index(4, \"down\", 5) == 4  # no wrap\nassert nav.get_next_index(0, \"up\", 5) == 0    # no wrap\n\n# Test with wrap\nnav_wrap = LinearVertical(wrap=True)\nassert nav_wrap.get_next_index(4, \"down\", 5) == 0  # wraps to start\nassert nav_wrap.get_next_index(0, \"up\", 5) == 4    # wraps to end",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#linearhorizontal",
    "href": "core/navigation.html#linearhorizontal",
    "title": "Navigation Patterns",
    "section": "LinearHorizontal",
    "text": "LinearHorizontal\nLeft/Right navigation through a horizontal list. Useful for word tokens in split mode, tabs, etc.\n\nsource\n\nLinearHorizontal\n\ndef LinearHorizontal(\n    wrap:bool=False\n)-&gt;None:\n\nLeft/Right navigation through a horizontal list.\n\n# Test LinearHorizontal\nnav = LinearHorizontal()\nassert nav.name == \"linear_horizontal\"\nassert nav.get_supported_directions() == (\"left\", \"right\")\nassert nav.get_next_index(0, \"right\", 5) == 1\nassert nav.get_next_index(4, \"right\", 5) == 4  # no wrap\nassert nav.get_next_index(0, \"left\", 5) == 0   # no wrap\n\n# Test with wrap\nnav_wrap = LinearHorizontal(wrap=True)\nassert nav_wrap.get_next_index(4, \"right\", 5) == 0  # wraps\nassert nav_wrap.get_next_index(0, \"left\", 5) == 4   # wraps",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#scrollonly",
    "href": "core/navigation.html#scrollonly",
    "title": "Navigation Patterns",
    "section": "ScrollOnly",
    "text": "ScrollOnly\nA navigation pattern for zones that are scrollable but don’t have selectable items (e.g., a preview panel).\n\nsource\n\nScrollOnly\n\ndef ScrollOnly(\n    \n)-&gt;None:\n\nNo item navigation, zone is scrollable content only.\n\n# Test ScrollOnly\nnav = ScrollOnly()\nassert nav.name == \"scroll_only\"\nassert nav.get_supported_directions() == ()\nassert nav.get_next_index(2, \"down\", 5) == 2  # unchanged",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#grid-placeholder",
    "href": "core/navigation.html#grid-placeholder",
    "title": "Navigation Patterns",
    "section": "Grid (Placeholder)",
    "text": "Grid (Placeholder)\n2D grid navigation for use in media galleries and similar UIs. Marked as placeholder for future implementation.\n\nsource\n\nGrid\n\ndef Grid(\n    columns:int=4, wrap_horizontal:bool=True, wrap_vertical:bool=False\n)-&gt;None:\n\n2D grid navigation (placeholder for future implementation).\n\n# Test Grid navigation\n# Grid with 4 columns, 10 items:\n# [0, 1, 2, 3]\n# [4, 5, 6, 7]\n# [8, 9]\ngrid = Grid(columns=4)\nassert grid.name == \"grid\"\nassert grid.get_supported_directions() == (\"up\", \"down\", \"left\", \"right\")\n\n# Horizontal navigation\nassert grid.get_next_index(0, \"right\", 10) == 1\nassert grid.get_next_index(3, \"right\", 10) == 0  # wraps\nassert grid.get_next_index(0, \"left\", 10) == 3   # wraps\n\n# Vertical navigation\nassert grid.get_next_index(1, \"down\", 10) == 5\nassert grid.get_next_index(5, \"up\", 10) == 1\nassert grid.get_next_index(9, \"down\", 10) == 9   # no vertical wrap by default",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/navigation.html#protocol-verification",
    "href": "core/navigation.html#protocol-verification",
    "title": "Navigation Patterns",
    "section": "Protocol Verification",
    "text": "Protocol Verification\n\n# Verify all implementations satisfy the protocol\nassert isinstance(LinearVertical(), NavigationPattern)\nassert isinstance(LinearHorizontal(), NavigationPattern)\nassert isinstance(ScrollOnly(), NavigationPattern)\nassert isinstance(Grid(), NavigationPattern)",
    "crumbs": [
      "core",
      "Navigation Patterns"
    ]
  },
  {
    "objectID": "core/actions.html",
    "href": "core/actions.html",
    "title": "Key Actions",
    "section": "",
    "text": "Declares a keyboard shortcut and its associated action. Actions can trigger HTMX requests, call JS functions, or switch modes.\n\nsource\n\n\n\ndef KeyAction(\n    key:str, modifiers:frozenset[str]=&lt;factory&gt;, htmx_trigger:Optional[str]=None, js_callback:Optional[str]=None,\n    mode_enter:Optional[str]=None, mode_exit:bool=False, prevent_default:bool=True, stop_propagation:bool=False,\n    zone_ids:Optional[tuple[str, ...]]=None, mode_names:Optional[tuple[str, ...]]=None,\n    not_modes:Optional[tuple[str, ...]]=None, custom_condition:Optional[str]=None, description:str='',\n    hint_group:str='General', show_in_hints:bool=True\n)-&gt;None:\n\nA keyboard shortcut binding.\n\n# Test basic KeyAction\naction = KeyAction(\n    key=\" \",  # Space\n    htmx_trigger=\"toggle-btn\",\n    description=\"Toggle selection\",\n    hint_group=\"Selection\"\n)\n\nassert action.key == \" \"\nassert action.htmx_trigger == \"toggle-btn\"\nassert action.get_display_key() == \"Space\"\nassert action.matches_context(\"any-zone\", \"any-mode\") == True\n\n\n# Test action with modifiers\nshift_action = KeyAction(\n    key=\"ArrowUp\",\n    modifiers=frozenset({\"shift\"}),\n    htmx_trigger=\"reorder-up\",\n    zone_ids=(\"queue\",),\n    description=\"Move item up\"\n)\n\nassert shift_action.get_display_key() == \"Shift+↑\"\nassert shift_action.matches_context(\"queue\", \"navigation\") == True\nassert shift_action.matches_context(\"browser\", \"navigation\") == False\n\n\n# Test mode-specific action\nsplit_action = KeyAction(\n    key=\"Enter\",\n    htmx_trigger=\"execute-split\",\n    mode_names=(\"split\",),\n    description=\"Split at caret\"\n)\n\nassert split_action.matches_context(\"any\", \"split\") == True\nassert split_action.matches_context(\"any\", \"navigation\") == False\n\n\n# Test action with not_modes\nnav_only_action = KeyAction(\n    key=\"Enter\",\n    mode_enter=\"split\",\n    not_modes=(\"split\",),  # don't enter split if already in split\n    description=\"Enter split mode\"\n)\n\nassert nav_only_action.matches_context(\"zone\", \"navigation\") == True\nassert nav_only_action.matches_context(\"zone\", \"split\") == False\n\n\n# Test JS callback action\naudition_action = KeyAction(\n    key=\"ArrowDown\",\n    js_callback=\"auditionCurrent\",\n    zone_ids=(\"vad-timeline\",),\n    description=\"Navigate and audition\"\n)\n\nconfig = audition_action.to_js_config()\nassert config[\"jsCallback\"] == \"auditionCurrent\"\nassert config[\"htmxTrigger\"] is None\nassert config[\"zoneIds\"] == [\"vad-timeline\"]",
    "crumbs": [
      "core",
      "Key Actions"
    ]
  },
  {
    "objectID": "core/actions.html#keyaction",
    "href": "core/actions.html#keyaction",
    "title": "Key Actions",
    "section": "",
    "text": "Declares a keyboard shortcut and its associated action. Actions can trigger HTMX requests, call JS functions, or switch modes.\n\nsource\n\n\n\ndef KeyAction(\n    key:str, modifiers:frozenset[str]=&lt;factory&gt;, htmx_trigger:Optional[str]=None, js_callback:Optional[str]=None,\n    mode_enter:Optional[str]=None, mode_exit:bool=False, prevent_default:bool=True, stop_propagation:bool=False,\n    zone_ids:Optional[tuple[str, ...]]=None, mode_names:Optional[tuple[str, ...]]=None,\n    not_modes:Optional[tuple[str, ...]]=None, custom_condition:Optional[str]=None, description:str='',\n    hint_group:str='General', show_in_hints:bool=True\n)-&gt;None:\n\nA keyboard shortcut binding.\n\n# Test basic KeyAction\naction = KeyAction(\n    key=\" \",  # Space\n    htmx_trigger=\"toggle-btn\",\n    description=\"Toggle selection\",\n    hint_group=\"Selection\"\n)\n\nassert action.key == \" \"\nassert action.htmx_trigger == \"toggle-btn\"\nassert action.get_display_key() == \"Space\"\nassert action.matches_context(\"any-zone\", \"any-mode\") == True\n\n\n# Test action with modifiers\nshift_action = KeyAction(\n    key=\"ArrowUp\",\n    modifiers=frozenset({\"shift\"}),\n    htmx_trigger=\"reorder-up\",\n    zone_ids=(\"queue\",),\n    description=\"Move item up\"\n)\n\nassert shift_action.get_display_key() == \"Shift+↑\"\nassert shift_action.matches_context(\"queue\", \"navigation\") == True\nassert shift_action.matches_context(\"browser\", \"navigation\") == False\n\n\n# Test mode-specific action\nsplit_action = KeyAction(\n    key=\"Enter\",\n    htmx_trigger=\"execute-split\",\n    mode_names=(\"split\",),\n    description=\"Split at caret\"\n)\n\nassert split_action.matches_context(\"any\", \"split\") == True\nassert split_action.matches_context(\"any\", \"navigation\") == False\n\n\n# Test action with not_modes\nnav_only_action = KeyAction(\n    key=\"Enter\",\n    mode_enter=\"split\",\n    not_modes=(\"split\",),  # don't enter split if already in split\n    description=\"Enter split mode\"\n)\n\nassert nav_only_action.matches_context(\"zone\", \"navigation\") == True\nassert nav_only_action.matches_context(\"zone\", \"split\") == False\n\n\n# Test JS callback action\naudition_action = KeyAction(\n    key=\"ArrowDown\",\n    js_callback=\"auditionCurrent\",\n    zone_ids=(\"vad-timeline\",),\n    description=\"Navigate and audition\"\n)\n\nconfig = audition_action.to_js_config()\nassert config[\"jsCallback\"] == \"auditionCurrent\"\nassert config[\"htmxTrigger\"] is None\nassert config[\"zoneIds\"] == [\"vad-timeline\"]",
    "crumbs": [
      "core",
      "Key Actions"
    ]
  },
  {
    "objectID": "core/actions.html#common-action-patterns",
    "href": "core/actions.html#common-action-patterns",
    "title": "Key Actions",
    "section": "Common Action Patterns",
    "text": "Common Action Patterns\n\n# Example: Toggle selection (common for browser/list UIs)\ntoggle_space = KeyAction(\n    key=\" \",\n    htmx_trigger=\"toggle-btn\",\n    description=\"Toggle selection\",\n    hint_group=\"Selection\"\n)\n\ntoggle_enter = KeyAction(\n    key=\"Enter\",\n    htmx_trigger=\"toggle-btn\",\n    not_modes=(\"split\", \"edit\"),  # don't toggle in edit modes\n    description=\"Toggle selection\",\n    hint_group=\"Selection\",\n    show_in_hints=False  # don't duplicate in hints since Space is shown\n)\n\n# Example: Delete/Remove actions\ndelete_action = KeyAction(\n    key=\"Delete\",\n    htmx_trigger=\"delete-btn\",\n    description=\"Delete item\",\n    hint_group=\"Actions\"\n)\n\nbackspace_delete = KeyAction(\n    key=\"Backspace\",\n    htmx_trigger=\"delete-btn\",\n    description=\"Delete item\",\n    hint_group=\"Actions\",\n    show_in_hints=False  # alternative key\n)",
    "crumbs": [
      "core",
      "Key Actions"
    ]
  },
  {
    "objectID": "htmx/inputs.html",
    "href": "htmx/inputs.html",
    "title": "Hidden Inputs",
    "section": "",
    "text": "Generate hidden inputs for tracking focused item data attributes.\nThe name attribute converts hyphens to underscores for Python/FastHTML compatibility: - HTML data attribute: data-item-id - Hidden input name: item_id - FastHTML route parameter: item_id\n\nsource\n\n\n\ndef render_zone_hidden_inputs(\n    zone:FocusZone, # the focus zone configuration\n)-&gt;list: # list of Hidden input components\n\nRender hidden inputs for a single zone’s data attributes.\n\n# Test zone inputs\nfrom fasthtml.common import to_xml\n\nzone = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr\",\n    data_attributes=(\"job-id\", \"plugin-name\")\n)\n\ninputs = render_zone_hidden_inputs(zone)\nassert len(inputs) == 2\n\nhtml = to_xml(inputs[0])\nassert 'id=\"browser-job-id\"' in html\n# Name converts hyphens to underscores for Python compatibility\nassert 'name=\"job_id\"' in html",
    "crumbs": [
      "htmx",
      "Hidden Inputs"
    ]
  },
  {
    "objectID": "htmx/inputs.html#zone-data-inputs",
    "href": "htmx/inputs.html#zone-data-inputs",
    "title": "Hidden Inputs",
    "section": "",
    "text": "Generate hidden inputs for tracking focused item data attributes.\nThe name attribute converts hyphens to underscores for Python/FastHTML compatibility: - HTML data attribute: data-item-id - Hidden input name: item_id - FastHTML route parameter: item_id\n\nsource\n\n\n\ndef render_zone_hidden_inputs(\n    zone:FocusZone, # the focus zone configuration\n)-&gt;list: # list of Hidden input components\n\nRender hidden inputs for a single zone’s data attributes.\n\n# Test zone inputs\nfrom fasthtml.common import to_xml\n\nzone = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr\",\n    data_attributes=(\"job-id\", \"plugin-name\")\n)\n\ninputs = render_zone_hidden_inputs(zone)\nassert len(inputs) == 2\n\nhtml = to_xml(inputs[0])\nassert 'id=\"browser-job-id\"' in html\n# Name converts hyphens to underscores for Python compatibility\nassert 'name=\"job_id\"' in html",
    "crumbs": [
      "htmx",
      "Hidden Inputs"
    ]
  },
  {
    "objectID": "htmx/inputs.html#manager-hidden-inputs",
    "href": "htmx/inputs.html#manager-hidden-inputs",
    "title": "Hidden Inputs",
    "section": "Manager Hidden Inputs",
    "text": "Manager Hidden Inputs\nGenerate all hidden inputs for a ZoneManager.\n\nsource\n\nrender_hidden_inputs\n\ndef render_hidden_inputs(\n    manager:ZoneManager, # the zone manager configuration\n    include_state:bool=False, # include state tracking inputs\n    container_id:str='kb-hidden-inputs', # container element ID\n)-&gt;Div: # container with all hidden inputs\n\nRender all hidden inputs for keyboard navigation.\nDeduplicates inputs by ID - zones with the same hidden_input_prefix will share inputs rather than creating duplicates.\n\n# Test manager inputs\nfrom cjm_fasthtml_keyboard_navigation.core.manager import ZoneManager\n\nzone1 = FocusZone(id=\"z1\", data_attributes=(\"a\",))\nzone2 = FocusZone(id=\"z2\", data_attributes=(\"b\", \"c\"))\n\nmanager = ZoneManager(zones=(zone1, zone2))\ncontainer = render_hidden_inputs(manager)\n\nhtml = to_xml(container)\nassert 'id=\"kb-hidden-inputs\"' in html\nassert 'id=\"z1-a\"' in html\nassert 'id=\"z2-b\"' in html\nassert 'id=\"z2-c\"' in html\n\n\n# Test deduplication - zones with same prefix share inputs\nzone_browser = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr\",\n    data_attributes=(\"job-id\", \"plugin-name\"),\n    hidden_input_prefix=\"sd-focused\"\n)\nzone_queue = FocusZone(\n    id=\"queue\",\n    item_selector=\"li\",\n    data_attributes=(\"job-id\", \"plugin-name\"),\n    hidden_input_prefix=\"sd-focused\"  # Same prefix as browser\n)\n\nmanager_shared = ZoneManager(zones=(zone_browser, zone_queue))\ncontainer = render_hidden_inputs(manager_shared)\n\nhtml = to_xml(container)\n# Should only have 2 inputs (deduplicated), not 4\nassert html.count('id=\"sd-focused-job-id\"') == 1\nassert html.count('id=\"sd-focused-plugin-name\"') == 1\nassert html.count('&lt;input') == 2\n\n\n# Test with state inputs\ncontainer = render_hidden_inputs(manager, include_state=True)\nhtml = to_xml(container)\nassert 'id=\"kb-active-zone\"' in html\nassert 'id=\"kb-current-mode\"' in html",
    "crumbs": [
      "htmx",
      "Hidden Inputs"
    ]
  },
  {
    "objectID": "htmx/inputs.html#include-selector-builder",
    "href": "htmx/inputs.html#include-selector-builder",
    "title": "Hidden Inputs",
    "section": "Include Selector Builder",
    "text": "Include Selector Builder\nBuild hx-include selector for HTMX requests.\n\nsource\n\nbuild_include_selector\n\ndef build_include_selector(\n    zone:FocusZone, # the zone to include inputs from\n    include_state:bool=False, # include state inputs\n)-&gt;str: # CSS selector for hx-include\n\nBuild hx-include selector for zone’s hidden inputs.\n\n# Test include selector\nzone = FocusZone(\n    id=\"browser\",\n    data_attributes=(\"job-id\", \"plugin-name\")\n)\n\nselector = build_include_selector(zone)\nassert selector == \"#browser-job-id, #browser-plugin-name\"\n\nselector_with_state = build_include_selector(zone, include_state=True)\nassert \"#kb-active-zone\" in selector_with_state\n\n\nsource\n\n\nbuild_all_zones_include_selector\n\ndef build_all_zones_include_selector(\n    manager:ZoneManager, # the zone manager\n    include_state:bool=False, # include state inputs\n)-&gt;str: # CSS selector for all zones\n\nBuild hx-include selector for all zones’ hidden inputs.\nDeduplicates selectors - zones with the same hidden_input_prefix will only include each input once.\n\n# Test all zones selector\nselector = build_all_zones_include_selector(manager)\nassert \"#z1-a\" in selector\nassert \"#z2-b\" in selector\nassert \"#z2-c\" in selector\n\n\n# Test deduplication in selector - zones with same prefix\nselector = build_all_zones_include_selector(manager_shared)\n# Should only have 2 selectors (deduplicated), not 4\nassert selector.count(\"#sd-focused-job-id\") == 1\nassert selector.count(\"#sd-focused-plugin-name\") == 1\nassert selector == \"#sd-focused-job-id, #sd-focused-plugin-name\"",
    "crumbs": [
      "htmx",
      "Hidden Inputs"
    ]
  },
  {
    "objectID": "js/generators.html",
    "href": "js/generators.html",
    "title": "Script Generators",
    "section": "",
    "text": "source\n\n\n\ndef js_zone_state(\n    \n)-&gt;str: # JavaScript state and getter/setter code\n\nGenerate JavaScript code for zone state management.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#zone-state-management",
    "href": "js/generators.html#zone-state-management",
    "title": "Script Generators",
    "section": "",
    "text": "source\n\n\n\ndef js_zone_state(\n    \n)-&gt;str: # JavaScript state and getter/setter code\n\nGenerate JavaScript code for zone state management.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#focus-management",
    "href": "js/generators.html#focus-management",
    "title": "Script Generators",
    "section": "Focus Management",
    "text": "Focus Management\n\nsource\n\njs_focus_management\n\ndef js_focus_management(\n    \n)-&gt;str: # JavaScript focus management code\n\nGenerate JavaScript code for focus management.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#zone-switching",
    "href": "js/generators.html#zone-switching",
    "title": "Script Generators",
    "section": "Zone Switching",
    "text": "Zone Switching\n\nsource\n\njs_zone_switching\n\ndef js_zone_switching(\n    \n)-&gt;str: # JavaScript zone switching code\n\nGenerate JavaScript code for zone switching.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#navigation",
    "href": "js/generators.html#navigation",
    "title": "Script Generators",
    "section": "Navigation",
    "text": "Navigation\n\nsource\n\njs_navigation\n\ndef js_navigation(\n    \n)-&gt;str: # JavaScript navigation code\n\nGenerate JavaScript code for item navigation.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#mode-management",
    "href": "js/generators.html#mode-management",
    "title": "Script Generators",
    "section": "Mode Management",
    "text": "Mode Management\n\nsource\n\njs_mode_management\n\ndef js_mode_management(\n    \n)-&gt;str: # JavaScript mode management code\n\nGenerate JavaScript code for mode management.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#action-dispatch",
    "href": "js/generators.html#action-dispatch",
    "title": "Script Generators",
    "section": "Action Dispatch",
    "text": "Action Dispatch\n\nsource\n\njs_action_dispatch\n\ndef js_action_dispatch(\n    \n)-&gt;str: # JavaScript action dispatch code\n\nGenerate JavaScript code for action dispatch.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#keyboard-handler",
    "href": "js/generators.html#keyboard-handler",
    "title": "Script Generators",
    "section": "Keyboard Handler",
    "text": "Keyboard Handler\n\nsource\n\njs_keyboard_handler\n\ndef js_keyboard_handler(\n    \n)-&gt;str: # JavaScript keyboard handler code\n\nGenerate JavaScript code for keyboard event handling.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#state-notification",
    "href": "js/generators.html#state-notification",
    "title": "Script Generators",
    "section": "State Notification",
    "text": "State Notification\n\nsource\n\njs_state_notification\n\ndef js_state_notification(\n    \n)-&gt;str: # JavaScript state notification code\n\nGenerate JavaScript code for state change notification.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#initialization",
    "href": "js/generators.html#initialization",
    "title": "Script Generators",
    "section": "Initialization",
    "text": "Initialization\nAfter HTMX swaps, the DOM changes but our state (focus indices) may be stale. The initialization function: 1. Reads the hidden input values (set before the swap) 2. Finds items with matching data attributes in the new DOM 3. Updates focus indices to follow moved/reordered items 4. Falls back to clamping if item not found (deleted)\n\nsource\n\njs_initialization\n\ndef js_initialization(\n    \n)-&gt;str: # JavaScript initialization code\n\nGenerate JavaScript code for initialization with focus recovery.",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  },
  {
    "objectID": "js/generators.html#global-api",
    "href": "js/generators.html#global-api",
    "title": "Script Generators",
    "section": "Global API",
    "text": "Global API\nExpose mode control functions globally for programmatic access from external code (e.g., HTMX responses that need to sync mode state).\n\nsource\n\njs_global_api\n\ndef js_global_api(\n    \n)-&gt;str: # JavaScript global API exposure code\n\nGenerate JavaScript code to expose mode control functions globally.\n\nsource\n\n\ngenerate_keyboard_script\n\ndef generate_keyboard_script(\n    manager:ZoneManager, # the zone manager configuration\n)-&gt;str: # complete JavaScript code wrapped in IIFE\n\nGenerate complete keyboard navigation JavaScript from ZoneManager.\n\n# Test complete script generation\nfrom cjm_fasthtml_keyboard_navigation.core.focus_zone import FocusZone\nfrom cjm_fasthtml_keyboard_navigation.core.actions import KeyAction\n\nbrowser = FocusZone(\n    id=\"browser\",\n    item_selector=\"tr.item\",\n    data_attributes=(\"job-id\",)\n)\nqueue = FocusZone(\n    id=\"queue\",\n    item_selector=\"li.item\"\n)\n\nmanager = ZoneManager(\n    zones=(browser, queue),\n    actions=(\n        KeyAction(key=\" \", htmx_trigger=\"toggle-btn\"),\n        KeyAction(key=\"Delete\", htmx_trigger=\"delete-btn\"),\n    )\n)\n\nscript = generate_keyboard_script(manager)\n\n# Verify key parts are present\nassert \"(function()\" in script\nassert \"const cfg\" in script\nassert \"isInputFocused\" in script\nassert \"handleKeydown\" in script\nassert \"initialize\" in script\nassert \"window.kbNav\" in script  # Global API\nassert \"window.kbNav.enterMode\" in script\nassert \"window.kbNav.exitMode\" in script\nassert \"})();\" in script",
    "crumbs": [
      "js",
      "Script Generators"
    ]
  }
]