"""Coordinates keyboard navigation across multiple zones, modes, and actions."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/manager.ipynb.

# %% ../../nbs/core/manager.ipynb #9779ede7
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Optional

from .focus_zone import FocusZone
from .modes import KeyboardMode, NAVIGATION_MODE
from .actions import KeyAction
from .key_mapping import KeyMapping, ARROW_KEYS

# %% auto #0
__all__ = ['ZoneManager']

# %% ../../nbs/core/manager.ipynb #4bfe7f9e
@dataclass
class ZoneManager:
    """Coordinates keyboard navigation across zones."""

    # Zones
    zones: tuple[FocusZone, ...]  # all focus zones

    # Zone switching
    prev_zone_key: str = "ArrowLeft"  # key to switch to previous zone
    next_zone_key: str = "ArrowRight"  # key to switch to next zone
    zone_switch_modifiers: frozenset[str] = field(
        default_factory=frozenset
    )  # modifiers for zone switching
    wrap_zones: bool = True  # wrap from last zone to first

    # Key mapping for navigation
    key_mapping: KeyMapping = field(
        default_factory=lambda: ARROW_KEYS
    )  # key-to-direction mapping

    # Initial state
    initial_zone_id: Optional[str] = None  # defaults to first zone

    # Modes
    modes: tuple[KeyboardMode, ...] = ()  # custom modes (navigation mode is implicit)
    default_mode: str = "navigation"  # mode to return to after exiting others

    # Actions
    actions: tuple[KeyAction, ...] = ()  # keyboard action bindings

    # Global callbacks (JS function names)
    on_zone_change: Optional[str] = None  # called when active zone changes
    on_mode_change: Optional[str] = None  # called when mode changes
    on_state_change: Optional[str] = None  # called on any state change (for persistence)

    # Input detection
    skip_when_input_focused: bool = True  # ignore keys in input/textarea
    input_selector: str = "input, textarea, select, [contenteditable]"  # elements to skip

    # HTMX integration
    htmx_settle_event: str = "htmx:afterSettle"  # event to reinitialize on

    # State exposure
    expose_state_globally: bool = False  # expose state on window object
    global_state_name: str = "keyboardNavState"  # name for global state
    state_hidden_inputs: bool = False  # write state to hidden inputs

    def __post_init__(self):
        """Validate configuration."""
        if not self.zones:
            raise ValueError("At least one zone is required")
        
        # Check for duplicate zone IDs
        zone_ids = [z.id for z in self.zones]
        if len(zone_ids) != len(set(zone_ids)):
            raise ValueError("Duplicate zone IDs detected")
        
        # Validate initial_zone_id
        if self.initial_zone_id and self.initial_zone_id not in zone_ids:
            raise ValueError(f"initial_zone_id '{self.initial_zone_id}' not found in zones")

    def get_zone(
        self,
        zone_id: str  # zone ID to find
    ) -> Optional[FocusZone]: # the zone or None
        """Get zone by ID."""
        for zone in self.zones:
            if zone.id == zone_id:
                return zone
        return None

    def get_initial_zone_id(self) -> str: # the initial zone ID
        """Get initial zone ID."""
        return self.initial_zone_id or self.zones[0].id

    def get_all_modes(self) -> tuple[KeyboardMode, ...]: # all modes including default
        """Get all modes including the default navigation mode."""
        return (NAVIGATION_MODE,) + self.modes

    def get_mode(
        self,
        mode_name: str  # mode name to find
    ) -> Optional[KeyboardMode]: # the mode or None
        """Get mode by name."""
        for mode in self.get_all_modes():
            if mode.name == mode_name:
                return mode
        return None

    def get_actions_for_context(
        self,
        zone_id: str,  # current zone
        mode_name: str  # current mode
    ) -> list[KeyAction]: # actions valid in this context
        """Get actions valid for given zone and mode."""
        return [
            action for action in self.actions
            if action.matches_context(zone_id, mode_name)
        ]

    def get_all_data_attributes(self) -> set[str]: # unique data attributes across all zones
        """Get all unique data attributes from all zones."""
        attrs = set()
        for zone in self.zones:
            attrs.update(zone.data_attributes)
        return attrs

    def to_js_config(self) -> dict: # JavaScript-compatible configuration
        """Convert to JavaScript configuration object."""
        return {
            "zones": [z.to_js_config() for z in self.zones],
            "zoneSwitching": {
                "prevKey": self.prev_zone_key,
                "nextKey": self.next_zone_key,
                "modifiers": list(self.zone_switch_modifiers),
                "wrap": self.wrap_zones,
            },
            "keyMapping": self.key_mapping.to_js_map(),
            "initialZoneId": self.get_initial_zone_id(),
            "modes": [m.to_js_config() for m in self.get_all_modes()],
            "defaultMode": self.default_mode,
            "actions": [a.to_js_config() for a in self.actions],
            "callbacks": {
                "onZoneChange": self.on_zone_change,
                "onModeChange": self.on_mode_change,
                "onStateChange": self.on_state_change,
            },
            "settings": {
                "skipWhenInputFocused": self.skip_when_input_focused,
                "inputSelector": self.input_selector,
                "htmxSettleEvent": self.htmx_settle_event,
                "exposeStateGlobally": self.expose_state_globally,
                "globalStateName": self.global_state_name,
                "stateHiddenInputs": self.state_hidden_inputs,
            },
        }
