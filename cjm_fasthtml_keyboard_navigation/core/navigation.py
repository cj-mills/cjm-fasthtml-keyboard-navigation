"""Protocols and implementations for keyboard navigation within focus zones."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/navigation.ipynb.

# %% ../../nbs/core/navigation.ipynb #30bddad4
from __future__ import annotations
from dataclasses import dataclass
from typing import Literal, Protocol, runtime_checkable

# %% auto #0
__all__ = ['Direction', 'NavigationPattern', 'LinearVertical', 'LinearHorizontal', 'ScrollOnly', 'Grid']

# %% ../../nbs/core/navigation.ipynb #78f7bbeb
Direction = Literal["up", "down", "left", "right"]

# %% ../../nbs/core/navigation.ipynb #c9c487f1
@runtime_checkable
class NavigationPattern(Protocol):
    """Protocol for navigation within a focus zone."""

    @property
    def name(self) -> str: # unique identifier for this pattern
        """Return the pattern name."""
        ...

    def get_next_index(
        self,
        current: int,      # current focused index
        direction: Direction, # navigation direction
        total: int,        # total number of items
        columns: int = 1   # number of columns (for grid navigation)
    ) -> int:              # the new index after navigation
        """Calculate next index given current position and direction."""
        ...

    def get_supported_directions(self) -> tuple[Direction, ...]: # directions this pattern responds to
        """Return which arrow key directions this pattern handles."""
        ...

# %% ../../nbs/core/navigation.ipynb #302be7a1
@dataclass
class LinearVertical:
    """Up/Down navigation through a vertical list."""
    wrap: bool = False # wrap from last item to first (and vice versa)

    @property
    def name(self) -> str:
        """Return the pattern name."""
        return "linear_vertical"

    def get_supported_directions(self) -> tuple[Direction, ...]: # ("up", "down")
        """Return supported directions."""
        return ("up", "down")

    def get_next_index(
        self,
        current: int,      # current focused index
        direction: Direction, # "up" or "down"
        total: int,        # total number of items
        columns: int = 1   # unused for linear navigation
    ) -> int:              # the new index
        """Calculate next index for vertical navigation."""
        if total == 0:
            return 0
        if direction == "down":
            new = current + 1
            if new >= total:
                return 0 if self.wrap else total - 1
            return new
        elif direction == "up":
            new = current - 1
            if new < 0:
                return total - 1 if self.wrap else 0
            return new
        return current

# %% ../../nbs/core/navigation.ipynb #89fdf502
@dataclass
class LinearHorizontal:
    """Left/Right navigation through a horizontal list."""
    wrap: bool = False # wrap from last item to first (and vice versa)

    @property
    def name(self) -> str:
        """Return the pattern name."""
        return "linear_horizontal"

    def get_supported_directions(self) -> tuple[Direction, ...]: # ("left", "right")
        """Return supported directions."""
        return ("left", "right")

    def get_next_index(
        self,
        current: int,      # current focused index
        direction: Direction, # "left" or "right"
        total: int,        # total number of items
        columns: int = 1   # unused for linear navigation
    ) -> int:              # the new index
        """Calculate next index for horizontal navigation."""
        if total == 0:
            return 0
        if direction == "right":
            new = current + 1
            if new >= total:
                return 0 if self.wrap else total - 1
            return new
        elif direction == "left":
            new = current - 1
            if new < 0:
                return total - 1 if self.wrap else 0
            return new
        return current

# %% ../../nbs/core/navigation.ipynb #f2bfd582
@dataclass
class ScrollOnly:
    """No item navigation, zone is scrollable content only."""

    @property
    def name(self) -> str:
        """Return the pattern name."""
        return "scroll_only"

    def get_supported_directions(self) -> tuple[Direction, ...]: # empty tuple
        """Return no supported directions."""
        return ()

    def get_next_index(
        self,
        current: int,      # current index (unused)
        direction: Direction, # direction (unused)
        total: int,        # total items (unused)
        columns: int = 1   # columns (unused)
    ) -> int:              # always returns current
        """Return current index unchanged."""
        return current

# %% ../../nbs/core/navigation.ipynb #23a3c4d7
@dataclass
class Grid:
    """2D grid navigation (placeholder for future implementation)."""
    columns: int = 4           # number of columns in the grid
    wrap_horizontal: bool = True  # wrap at row edges
    wrap_vertical: bool = False   # wrap at grid top/bottom

    @property
    def name(self) -> str:
        """Return the pattern name."""
        return "grid"

    def get_supported_directions(self) -> tuple[Direction, ...]: # all four directions
        """Return all four directions."""
        return ("up", "down", "left", "right")

    def get_next_index(
        self,
        current: int,      # current focused index
        direction: Direction, # navigation direction
        total: int,        # total number of items
        columns: int = 0   # override columns (0 = use self.columns)
    ) -> int:              # the new index
        """Calculate next index for 2D grid navigation."""
        if total == 0:
            return 0
        
        cols = columns if columns > 0 else self.columns
        row, col = divmod(current, cols)
        rows = (total + cols - 1) // cols  # ceiling division

        if direction == "right":
            new_col = col + 1
            if new_col >= cols:
                new_col = 0 if self.wrap_horizontal else cols - 1
            new_idx = row * cols + new_col
            return min(new_idx, total - 1)
        
        elif direction == "left":
            new_col = col - 1
            if new_col < 0:
                new_col = cols - 1 if self.wrap_horizontal else 0
            new_idx = row * cols + new_col
            return min(new_idx, total - 1)
        
        elif direction == "down":
            new_row = row + 1
            if new_row >= rows:
                new_row = 0 if self.wrap_vertical else rows - 1
            new_idx = new_row * cols + col
            return min(new_idx, total - 1)
        
        elif direction == "up":
            new_row = row - 1
            if new_row < 0:
                new_row = rows - 1 if self.wrap_vertical else 0
            new_idx = new_row * cols + col
            return min(new_idx, total - 1)
        
        return current
